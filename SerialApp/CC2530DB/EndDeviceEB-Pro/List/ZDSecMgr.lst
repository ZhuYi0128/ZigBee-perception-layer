###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         06/Aug/2016  17:34:27 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\zhuyi\Desktop\2016 µçÈü                   #
#                          ¾öÈü\8.6\Components\stack\zdo\ZDSecMgr.c           #
#    Command line       =  -f "C:\Users\zhuyi\Desktop\2016 µçÈü               #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"          #
#                          (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS) -f    #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"         #
#                          (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR      #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Components\stack\zdo\ZDSecMgr.c" -D       #
#                          ZIGBEEPRO -D NWK_AUTO_POLL -D HAL_UART=TRUE -D     #
#                          SERIAL_APP_PORT=0 -D LCD_SUPPORTED -D              #
#                          xPOWER_SAVING -lC "C:\Users\zhuyi\Desktop\2016     #
#                          µçÈü  ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp #
#                          \CC2530DB\EndDeviceEB-Pro\List\" -lA               #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\EndDeviceEB-Pro\List\" --diag_suppress         #
#                          Pe001,Pa010 -o "C:\Users\zhuyi\Desktop\2016 µçÈü   #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\EndDeviceEB-Pro\Obj\" -e --no_unroll           #
#                          --no_inline --no_tbaa --debug --core=plain         #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "C:\Users\zhuyi\Desktop\201 #
#                          6 µçÈü  ¾öÈü\8.6\Projects\zstack\Utilities\SerialA #
#                          pp\CC2530DB\" -I "C:\Users\zhuyi\Desktop\2016      #
#                          µçÈü  ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp #
#                          \CC2530DB\..\SOURCE\" -I                           #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\ZMAIN\TI2530DB\" -I                   #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\MT\" -I              #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\" -I     #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\ #
#                          " -I "C:\Users\zhuyi\Desktop\2016 µçÈü             #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\" -I  #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\" -I    #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\STACK\AF\" -I        #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\STACK\NWK\" -I       #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\STACK\SEC\" -I       #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\" -I      #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\STACK\SYS\" -I       #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\" -I       #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\" -I        #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\ZMAC\" -I            #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\" -I  #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\" -I  #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\" -I     #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I  #
#                          "C:\Users\zhuyi\Desktop\2016 µçÈü                  #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\ #
#                          " -I "C:\Users\zhuyi\Desktop\2016 µçÈü             #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\ #
#                          SINGLE_CHIP\" -Om --require_prototypes             #
#    List file          =  C:\Users\zhuyi\Desktop\2016 µçÈü                   #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\EndDeviceEB-Pro\List\ZDSecMgr.lst              #
#    Object file        =  C:\Users\zhuyi\Desktop\2016 µçÈü                   #
#                          ¾öÈü\8.6\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\EndDeviceEB-Pro\Obj\ZDSecMgr.r51               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\zhuyi\Desktop\2016 µçÈü  ¾öÈü\8.6\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2009-03-31 09:06:47 -0700 (Tue, 31 Mar 2009) $
      4            Revision:       $Revision: 19604 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2008 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          #define ZDSECMGR_CTRL_NONE       0
     93          #define ZDSECMGR_CTRL_INIT       1
     94          #define ZDSECMGR_CTRL_TK_MASTER  2
     95          #define ZDSECMGR_CTRL_SKKE_INIT  3
     96          #define ZDSECMGR_CTRL_SKKE_WAIT  4
     97          #define ZDSECMGR_CTRL_SKKE_DONE  5
     98          #define ZDSECMGR_CTRL_SKKE_FAIL  6
     99          #define ZDSECMGR_CTRL_TK_NWK     7
    100          
    101          #define ZDSECMGR_CTRL_BASE_CNTR      1
    102          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    103          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    104          
    105          // set SKA slot maximum
    106          #define ZDSECMGR_SKA_SLOT_MAX 1
    107          
    108          // APSME Stub Implementations
    109          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    110          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    111          #define ZDSecMgrLinkKeyDataGet APSME_LinkKeyDataGet
    112          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    113          
    114          #if !defined( MAX_APS_FRAMECOUNTER_CHANGES )
    115            // The number of times the frame counter can change before
    116            // saving to NV
    117            #define MAX_APS_FRAMECOUNTER_CHANGES    10
    118          #endif
    119          
    120          /******************************************************************************
    121           * TYPEDEFS
    122           */
    123          typedef struct
    124          {
    125            uint8 extAddr[Z_EXTADDR_LEN];
    126            uint8 key[SEC_KEY_LEN];
    127          } ZDSecMgrPreConfigData_t;
    128          
    129          typedef struct
    130          {
    131            uint16 ami;
    132            uint8  key[SEC_KEY_LEN];
    133          } ZDSecMgrMasterKeyData_t;
    134          
    135          //should match APSME_LinkKeyData_t;
    136          typedef struct
    137          {
    138            uint8               key[SEC_KEY_LEN];
    139            APSME_LinkKeyData_t apsmelkd;
    140          } ZDSecMgrLinkKeyData_t;
    141          
    142          typedef struct
    143          {
    144            uint16                ami;
    145            ZDSecMgrLinkKeyData_t lkd;
    146            ZDSecMgr_Authentication_Option authenticateOption;
    147          } ZDSecMgrEntry_t;
    148          
    149          typedef struct
    150          {
    151            ZDSecMgrEntry_t* entry;
    152            uint16           parentAddr;
    153            uint8            secure;
    154            uint8            state;
    155            uint8            cntr;
    156            //uint8          next;
    157          } ZDSecMgrCtrl_t;
    158          
    159          typedef struct
    160          {
    161            uint16          nwkAddr;
    162            uint8*          extAddr;
    163            uint16          parentAddr;
    164            uint8           secure;
    165            uint8           devStatus;
    166            ZDSecMgrCtrl_t* ctrl;
    167          } ZDSecMgrDevice_t;
    168          
    169          /******************************************************************************
    170           * LOCAL VARIABLES
    171           */
    172          #if 0 // Taken out because the following functionality is only used for test
    173                // purpose. A more efficient (above) way is used. It can be put
    174                // back in if customers request for a white/black list feature.
    175          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    176          {
    177            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    178            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    179            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    180          };
    181          #endif
    182          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    184            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    185          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    186          uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for ZDSecMgrTCMasterKey>`
   \   000010                REQUIRE __INIT_XDATA_I
    187            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    188             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    189          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    190          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    191          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    192          
    193          //devtag.pro.security - remove this
    194          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    195          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    196          {
    197            //---------------------------------------------------------------------------
    198            // DEVICE A
    199            //---------------------------------------------------------------------------
    200            {
    201              // extAddr
    202              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    203          
    204              // key
    205              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    206               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    207            },
    208            //---------------------------------------------------------------------------
    209            // DEVICE B
    210            //---------------------------------------------------------------------------
    211            {
    212              // extAddr
    213              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    214          
    215              // key
    216              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    217               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    218            },
    219            //---------------------------------------------------------------------------
    220            // DEVICE C
    221            //---------------------------------------------------------------------------
    222            {
    223              // extAddr
    224              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    225          
    226              // key
    227              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    228               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    229            },
    230          };
    231          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    232          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    233          ZDSecMgrMasterKeyData_t* ZDSecMgrMasterKeyData = NULL;
   \                     ZDSecMgrMasterKeyData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    234          ZDSecMgrEntry_t*         ZDSecMgrEntries       = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          ZDSecMgrCtrl_t*          ZDSecMgrCtrlData      = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    236          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    237          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    238          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    239          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    240          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    241          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    242          APSME_LinkKeyData_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z
    243          
    244          /******************************************************************************
    245           * PRIVATE FUNCTIONS
    246           *
    247           *   ZDSecMgrMasterKeyInit
    248           *   ZDSecMgrAddrStore
    249           *   ZDSecMgrExtAddrStore
    250           *   ZDSecMgrExtAddrLookup
    251           *   ZDSecMgrMasterKeyLookup
    252           *   ZDSecMgrMasterKeyStore
    253           *   ZDSecMgrEntryInit
    254           *   ZDSecMgrEntryLookup
    255           *   ZDSecMgrEntryLookupAMI
    256           *   ZDSecMgrEntryLookupExt
    257           *   ZDSecMgrEntryFree
    258           *   ZDSecMgrEntryNew
    259           *   ZDSecMgrCtrlInit
    260           *   ZDSecMgrCtrlRelease
    261           *   ZDSecMgrCtrlLookup
    262           *   ZDSecMgrCtrlSet
    263           *   ZDSecMgrCtrlAdd
    264           *   ZDSecMgrCtrlTerm
    265           *   ZDSecMgrCtrlReset
    266           *   ZDSecMgrMasterKeyLoad
    267           *   ZDSecMgrAppKeyGet
    268           *   ZDSecMgrAppKeyReq
    269           *   ZDSecMgrEstablishKey
    270           *   ZDSecMgrSendMasterKey
    271           *   ZDSecMgrSendNwkKey
    272           *   ZDSecMgrDeviceEntryRemove
    273           *   ZDSecMgrDeviceEntryAdd
    274           *   ZDSecMgrDeviceCtrlHandler
    275           *   ZDSecMgrDeviceCtrlSetup
    276           *   ZDSecMgrDeviceCtrlUpdate
    277           *   ZDSecMgrDeviceRemove
    278           *   ZDSecMgrDeviceValidateSKKE
    279           *   ZDSecMgrDeviceValidateRM
    280           *   ZDSecMgrDeviceValidateCM
    281           *   ZDSecMgrDeviceValidate
    282           *   ZDSecMgrDeviceJoin
    283           *   ZDSecMgrDeviceJoinDirect
    284           *   ZDSecMgrDeviceJoinFwd
    285           *   ZDSecMgrDeviceNew
    286           *   ZDSecMgrAssocDeviceAuth
    287           *   ZDSecMgrAuthInitiate
    288           *   ZDSecMgrAuthNwkKey
    289           */
    290          //-----------------------------------------------------------------------------
    291          // master key data
    292          //-----------------------------------------------------------------------------
    293          void ZDSecMgrMasterKeyInit( void );
    294          
    295          //-----------------------------------------------------------------------------
    296          // address management
    297          //-----------------------------------------------------------------------------
    298          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    299          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    300          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    301          
    302          //-----------------------------------------------------------------------------
    303          // MASTER key data
    304          //-----------------------------------------------------------------------------
    305          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key );
    306          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    307          
    308          //-----------------------------------------------------------------------------
    309          // entry data
    310          //-----------------------------------------------------------------------------
    311          void ZDSecMgrEntryInit( void );
    312          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    313          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    314          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    315          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    316          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    318          
    319          //-----------------------------------------------------------------------------
    320          // control data
    321          //-----------------------------------------------------------------------------
    322          void ZDSecMgrCtrlInit( void );
    323          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    324          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    325          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    326                                ZDSecMgrEntry_t*  entry,
    327                                ZDSecMgrCtrl_t*   ctrl );
    328          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    329          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    330          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    331                                       ZDSecMgrEntry_t*  entry );
    332          
    333          //-----------------------------------------------------------------------------
    334          // key support
    335          //-----------------------------------------------------------------------------
    336          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    337          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    338                                       uint8*  initExtAddr,
    339                                       uint16  partNwkAddr,
    340                                       uint8*  partExtAddr,
    341                                       uint8** key,
    342                                       uint8*  keyType );
    343          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    344          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    345          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    346          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    347          
    348          //-----------------------------------------------------------------------------
    349          // device entry
    350          //-----------------------------------------------------------------------------
    351          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    352          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    353          
    354          //-----------------------------------------------------------------------------
    355          // device control
    356          //-----------------------------------------------------------------------------
    357          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    358          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    359          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    360          
    361          //-----------------------------------------------------------------------------
    362          // device management
    363          //-----------------------------------------------------------------------------
    364          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    365          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    366          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    367          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    368          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    369          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    370          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    371          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    372          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    373          
    374          //-----------------------------------------------------------------------------
    375          // association management
    376          //-----------------------------------------------------------------------------
    377          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    378          
    379          //-----------------------------------------------------------------------------
    380          // authentication management
    381          //-----------------------------------------------------------------------------
    382          void ZDSecMgrAuthInitiate( uint8* responder );
    383          void ZDSecMgrAuthNwkKey( void );
    384          
    385          /******************************************************************************
    386           * @fn          ZDSecMgrMasterKeyInit                     ]
    387           *
    388           * @brief       Initialize master key data.
    389           *
    390           * @param       none
    391           *
    392           * @return      none
    393           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    394          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    395          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    396            uint16 index;
    397            uint16 size;
    398          
    399            // allocate MASTER key data
    400            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    401          
    402            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A36         MOV     R2,#0x36
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00000E   EA           MOV     A,R2
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   EB           MOV     A,R3
   \   000012   F0           MOVX    @DPTR,A
    403          
    404            // initialize MASTER key data
    405            if ( ZDSecMgrMasterKeyData != NULL )
   \   000013   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F8           MOV     R0,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F9           MOV     R1,A
   \   00001B   E8           MOV     A,R0
   \   00001C   49           ORL     A,R1
   \   00001D   603D         JZ      ??ZDSecMgrMasterKeyInit_0
    406            {
    407              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   00001F   7800         MOV     R0,#0x0
   \   000021   7900         MOV     R1,#0x0
   \   000023   802E         SJMP    ??ZDSecMgrMasterKeyInit_1
    408              {
    409                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   000025   E8           MOV     A,R0
   \   000026   FA           MOV     R2,A
   \   000027   E9           MOV     A,R1
   \   000028   FB           MOV     R3,A
   \   000029   EA           MOV     A,R2
   \   00002A   75F012       MOV     B,#0x12
   \   00002D   A4           MUL     AB
   \   00002E   FA           MOV     R2,A
   \   00002F   ACF0         MOV     R4,B
   \   000031   75F012       MOV     B,#0x12
   \   000034   EB           MOV     A,R3
   \   000035   A4           MUL     AB
   \   000036   2C           ADD     A,R4
   \   000037   FB           MOV     R3,A
   \   000038   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   2A           ADD     A,R2
   \   00003D   FC           MOV     R4,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   3B           ADDC    A,R3
   \   000041   8C82         MOV     DPL,R4
   \   000043   F583         MOV     DPH,A
   \   000045   74FE         MOV     A,#-0x2
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   04           INC     A
   \   00004A   F0           MOVX    @DPTR,A
    410              }
   \   00004B   E8           MOV     A,R0
   \   00004C   2401         ADD     A,#0x1
   \   00004E   08           INC     R0
   \   00004F   E9           MOV     A,R1
   \   000050   3400         ADDC    A,#0x0
   \   000052   F9           MOV     R1,A
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   000053   C3           CLR     C
   \   000054   E8           MOV     A,R0
   \   000055   9403         SUBB    A,#0x3
   \   000057   E9           MOV     A,R1
   \   000058   9400         SUBB    A,#0x0
   \   00005A   40C9         JC      ??ZDSecMgrMasterKeyInit_2
    411            }
    412          }
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00005C   D083         POP     DPH
   \   00005E   D082         POP     DPL
   \   000060   02....       LJMP    ?BRET
    413          //devtag.pro.security
    414          #if 0
    415          void ZDSecMgrMasterKeyInit( void )
    416          {
    417            uint16         index;
    418            uint16         size;
    419            AddrMgrEntry_t entry;
    420          
    421          
    422            // allocate MASTER key data
    423            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    424          
    425            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
    426          
    427            // initialize MASTER key data
    428            if ( ZDSecMgrMasterKeyData != NULL )
    429            {
    430              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    431              {
    432                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
    433              }
    434          
    435              // check if preconfigured keys are enabled
    436              //-------------------------------------------------------------------------
    437              #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    438              //-------------------------------------------------------------------------
    439              if ( zgPreConfigKeys == TRUE )
    440              {
    441                // sync configured data
    442                entry.user = ADDRMGR_USER_SECURITY;
    443          
    444                for ( index = 0; index < ZDSECMGR_PRECONFIG_MAX; index++ )
    445                {
    446                  // check for Address Manager entry
    447                  AddrMgrExtAddrSet( entry.extAddr,
    448                                     (uint8*)ZDSecMgrPreConfigData[index].extAddr );
    449          
    450                  if ( AddrMgrEntryLookupExt( &entry ) != TRUE )
    451                  {
    452                    // update Address Manager
    453                    AddrMgrEntryUpdate( &entry );
    454                  }
    455          
    456                  if ( entry.index != INVALID_NODE_ADDR )
    457                  {
    458                    // sync MASTER keys with Address Manager index
    459                    ZDSecMgrMasterKeyData[index].ami = entry.index;
    460          
    461                    osal_memcpy( ZDSecMgrMasterKeyData[index].key,
    462                             (void*)ZDSecMgrPreConfigData[index].key, SEC_KEY_LEN );
    463                  }
    464                }
    465              }
    466              //-------------------------------------------------------------------------
    467              #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    468              //-------------------------------------------------------------------------
    469            }
    470          }
    471          #endif
    472          
    473          /******************************************************************************
    474           * @fn          ZDSecMgrAddrStore
    475           *
    476           * @brief       Store device addresses.
    477           *
    478           * @param       nwkAddr - [in] NWK address
    479           * @param       extAddr - [in] EXT address
    480           * @param       ami     - [out] Address Manager index
    481           *
    482           * @return      ZStatus_t
    483           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    485          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FE           MOV     R6,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FF           MOV     R7,A
    486            ZStatus_t      status;
    487            AddrMgrEntry_t entry;
    488          
    489          
    490            // add entry
    491            entry.user    = ADDRMGR_USER_SECURITY;
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   7402         MOV     A,#0x2
   \   00001C   F0           MOVX    @DPTR,A
    492            entry.nwkAddr = nwkAddr;
   \   00001D   14           DEC     A
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   EA           MOV     A,R2
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   EB           MOV     A,R3
   \   000025   F0           MOVX    @DPTR,A
    493            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000026                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000026   7403         MOV     A,#0x3
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   AA82         MOV     R2,DPL
   \   00002D   AB83         MOV     R3,DPH
   \   00002F   12....       LCALL   ??AddrMgrExtAddrSet?relay
    494          
    495            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000032                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   AA82         MOV     R2,DPL
   \   00003A   AB83         MOV     R3,DPH
   \   00003C   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00003F   E9           MOV     A,R1
   \   000040   6401         XRL     A,#0x1
   \   000042   7017         JNZ     ??ZDSecMgrAddrStore_0
    496            {
    497              // return successful results
    498              *ami   = entry.index;
   \   000044   740B         MOV     A,#0xb
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F8           MOV     R0,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   8E82         MOV     DPL,R6
   \   000050   8F83         MOV     DPH,R7
   \   000052   E8           MOV     A,R0
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   E9           MOV     A,R1
   \   000056   F0           MOVX    @DPTR,A
    499              status = ZSuccess;
   \   000057   7900         MOV     R1,#0x0
   \   000059   8015         SJMP    ??ZDSecMgrAddrStore_1
    500            }
    501            else
    502            {
    503              // return failed results
    504              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00005B   740B         MOV     A,#0xb
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F8           MOV     R0,A
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F9           MOV     R1,A
   \   000065   8E82         MOV     DPL,R6
   \   000067   8F83         MOV     DPH,R7
   \   000069   E8           MOV     A,R0
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   A3           INC     DPTR
   \   00006C   E9           MOV     A,R1
   \   00006D   F0           MOVX    @DPTR,A
    505              status = ZNwkUnknownDevice;
   \   00006E   79C8         MOV     R1,#-0x38
    506            }
    507          
    508            return status;
   \                     ??ZDSecMgrAddrStore_1:
   \   000070   740D         MOV     A,#0xd
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
   \   000075   7F01         MOV     R7,#0x1
   \   000077   02....       LJMP    ?BANKED_LEAVE_XDATA
    509          }
    510          
    511          /******************************************************************************
    512           * @fn          ZDSecMgrExtAddrStore
    513           *
    514           * @brief       Store EXT address.
    515           *
    516           * @param       extAddr - [in] EXT address
    517           * @param       ami     - [out] Address Manager index
    518           *
    519           * @return      ZStatus_t
    520           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    521          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    522          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FE           MOV     R6,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FF           MOV     R7,A
    523            ZStatus_t      status;
    524            AddrMgrEntry_t entry;
    525          
    526          
    527            // add entry
    528            entry.user    = ADDRMGR_USER_SECURITY;
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   7402         MOV     A,#0x2
   \   00001C   F0           MOVX    @DPTR,A
    529            entry.nwkAddr = nwkAddr;
   \   00001D   14           DEC     A
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   EA           MOV     A,R2
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   EB           MOV     A,R3
   \   000025   F0           MOVX    @DPTR,A
    530            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000026                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000026   7403         MOV     A,#0x3
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   AA82         MOV     R2,DPL
   \   00002D   AB83         MOV     R3,DPH
   \   00002F   12....       LCALL   ??AddrMgrExtAddrSet?relay
    531          
    532            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000032                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   AA82         MOV     R2,DPL
   \   00003A   AB83         MOV     R3,DPH
   \   00003C   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00003F   E9           MOV     A,R1
   \   000040   6401         XRL     A,#0x1
   \   000042   7017         JNZ     ??ZDSecMgrExtAddrStore_0
    533            {
    534              // return successful results
    535              *ami   = entry.index;
   \   000044   740B         MOV     A,#0xb
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F8           MOV     R0,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   8E82         MOV     DPL,R6
   \   000050   8F83         MOV     DPH,R7
   \   000052   E8           MOV     A,R0
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   E9           MOV     A,R1
   \   000056   F0           MOVX    @DPTR,A
    536              status = ZSuccess;
   \   000057   7900         MOV     R1,#0x0
   \   000059   8015         SJMP    ??ZDSecMgrExtAddrStore_1
    537            }
    538            else
    539            {
    540              // return failed results
    541              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00005B   740B         MOV     A,#0xb
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F8           MOV     R0,A
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F9           MOV     R1,A
   \   000065   8E82         MOV     DPL,R6
   \   000067   8F83         MOV     DPH,R7
   \   000069   E8           MOV     A,R0
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   A3           INC     DPTR
   \   00006C   E9           MOV     A,R1
   \   00006D   F0           MOVX    @DPTR,A
    542              status = ZNwkUnknownDevice;
   \   00006E   79C8         MOV     R1,#-0x38
    543            }
    544          
    545            return status;
   \                     ??ZDSecMgrExtAddrStore_1:
   \   000070   740D         MOV     A,#0xd
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
   \   000075   7F01         MOV     R7,#0x1
   \   000077   02....       LJMP    ?BANKED_LEAVE_XDATA
    546          }
    547          
    548          /******************************************************************************
    549           * @fn          ZDSecMgrExtAddrLookup
    550           *
    551           * @brief       Lookup index for specified EXT address.
    552           *
    553           * @param       extAddr - [in] EXT address
    554           * @param       ami     - [out] Address Manager index
    555           *
    556           * @return      ZStatus_t
    557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    558          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    559          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    560            ZStatus_t      status;
    561            AddrMgrEntry_t entry;
    562          
    563          
    564            // lookup entry
    565            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
    566            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   AA82         MOV     R2,DPL
   \   000022   AB83         MOV     R3,DPH
   \   000024   12....       LCALL   ??AddrMgrExtAddrSet?relay
    567          
    568            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   AA82         MOV     R2,DPL
   \   00002F   AB83         MOV     R3,DPH
   \   000031   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000034   E9           MOV     A,R1
   \   000035   6401         XRL     A,#0x1
   \   000037   7017         JNZ     ??ZDSecMgrExtAddrLookup_0
    569            {
    570              // return successful results
    571              *ami   = entry.index;
   \   000039   740B         MOV     A,#0xb
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F8           MOV     R0,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F9           MOV     R1,A
   \   000043   8E82         MOV     DPL,R6
   \   000045   8F83         MOV     DPH,R7
   \   000047   E8           MOV     A,R0
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   E9           MOV     A,R1
   \   00004B   F0           MOVX    @DPTR,A
    572              status = ZSuccess;
   \   00004C   7900         MOV     R1,#0x0
   \   00004E   8015         SJMP    ??ZDSecMgrExtAddrLookup_1
    573            }
    574            else
    575            {
    576              // return failed results
    577              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000050   740B         MOV     A,#0xb
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   8E82         MOV     DPL,R6
   \   00005C   8F83         MOV     DPH,R7
   \   00005E   E8           MOV     A,R0
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   A3           INC     DPTR
   \   000061   E9           MOV     A,R1
   \   000062   F0           MOVX    @DPTR,A
    578              status = ZNwkUnknownDevice;
   \   000063   79C8         MOV     R1,#-0x38
    579            }
    580          
    581            return status;
   \                     ??ZDSecMgrExtAddrLookup_1:
   \   000065   740D         MOV     A,#0xd
   \   000067   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006A   7F01         MOV     R7,#0x1
   \   00006C   02....       LJMP    ?BANKED_LEAVE_XDATA
    582          }
    583          
    584          /******************************************************************************
    585           * @fn          ZDSecMgrMasterKeyLookup
    586           *
    587           * @brief       Lookup MASTER key for specified address index.
    588           *
    589           * @param       ami - [in] Address Manager index
    590           * @param       key - [out] valid MASTER key
    591           *
    592           * @return      ZStatus_t
    593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    594          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key )
   \                     ZDSecMgrMasterKeyLookup:
    595          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
    596            ZStatus_t status;
    597            uint16    index;
    598          
    599          
    600            // initialize results
    601            *key   = NULL;
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    602            status = ZNwkUnknownDevice;
   \   000011   75..C8       MOV     ?V0 + 0,#-0x38
    603          
    604            // verify data is available
    605            if ( ZDSecMgrMasterKeyData != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   605B         JZ      ??ZDSecMgrMasterKeyLookup_0
    606            {
    607              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000020   7800         MOV     R0,#0x0
   \   000022   7900         MOV     R1,#0x0
   \   000024   804C         SJMP    ??ZDSecMgrMasterKeyLookup_1
    608              {
    609                if ( ZDSecMgrMasterKeyData[index].ami == ami )
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   000026   E8           MOV     A,R0
   \   000027   FC           MOV     R4,A
   \   000028   E9           MOV     A,R1
   \   000029   FD           MOV     R5,A
   \   00002A   EC           MOV     A,R4
   \   00002B   75F012       MOV     B,#0x12
   \   00002E   A4           MUL     AB
   \   00002F   FC           MOV     R4,A
   \   000030   85F0..       MOV     ?V0 + 1,B
   \   000033   75F012       MOV     B,#0x12
   \   000036   ED           MOV     A,R5
   \   000037   A4           MUL     AB
   \   000038   25..         ADD     A,?V0 + 1
   \   00003A   FD           MOV     R5,A
   \   00003B   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   2C           ADD     A,R4
   \   000040   FC           MOV     R4,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   3D           ADDC    A,R5
   \   000044   FD           MOV     R5,A
   \   000045   8C82         MOV     DPL,R4
   \   000047   8D83         MOV     DPH,R5
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6A           XRL     A,R2
   \   00004B   7003         JNZ     ??ZDSecMgrMasterKeyLookup_3
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   6B           XRL     A,R3
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   000050   7018         JNZ     ??ZDSecMgrMasterKeyLookup_4
    610                {
    611                  // return successful results
    612                  *key   = ZDSecMgrMasterKeyData[index].key;
   \   000052   EC           MOV     A,R4
   \   000053   2402         ADD     A,#0x2
   \   000055   F8           MOV     R0,A
   \   000056   ED           MOV     A,R5
   \   000057   3400         ADDC    A,#0x0
   \   000059   F9           MOV     R1,A
   \   00005A   8E82         MOV     DPL,R6
   \   00005C   8F83         MOV     DPH,R7
   \   00005E   E8           MOV     A,R0
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   A3           INC     DPTR
   \   000061   E9           MOV     A,R1
   \   000062   F0           MOVX    @DPTR,A
    613                  status = ZSuccess;
   \   000063   75..00       MOV     ?V0 + 0,#0x0
    614          
    615                  // break from loop
    616                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   000066   7803         MOV     R0,#0x3
   \   000068   7900         MOV     R1,#0x0
    617                }
    618              }
   \                     ??ZDSecMgrMasterKeyLookup_4:
   \   00006A   E8           MOV     A,R0
   \   00006B   2401         ADD     A,#0x1
   \   00006D   08           INC     R0
   \   00006E   E9           MOV     A,R1
   \   00006F   3400         ADDC    A,#0x0
   \   000071   F9           MOV     R1,A
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   000072   C3           CLR     C
   \   000073   E8           MOV     A,R0
   \   000074   9403         SUBB    A,#0x3
   \   000076   E9           MOV     A,R1
   \   000077   9400         SUBB    A,#0x0
   \   000079   40AB         JC      ??ZDSecMgrMasterKeyLookup_2
    619            }
    620          
    621            return status;
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   00007B   A9..         MOV     R1,?V0 + 0
   \   00007D   7F02         MOV     R7,#0x2
   \   00007F   02....       LJMP    ?BANKED_LEAVE_XDATA
    622          }
    623          
    624          /******************************************************************************
    625           * @fn          ZDSecMgrMasterKeyStore
    626           *
    627           * @brief       Store MASTER key for specified address index.
    628           *
    629           * @param       ami - [in] Address Manager index
    630           * @param       key - [in] valid key to store
    631           *
    632           * @return      ZStatus_t
    633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    634          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    635          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 4,R2
   \   000007   8B..         MOV     ?V0 + 5,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    636            ZStatus_t status;
    637            uint16    index;
    638            uint8*    entry;
    639          
    640          
    641            // initialize results
    642            status = ZNwkUnknownDevice;
   \   00000D   75..C8       MOV     ?V0 + 0,#-0x38
    643          
    644            // verify data is available
    645            if ( ZDSecMgrMasterKeyData != NULL )
   \   000010   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    646            {
    647              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   00001F   7A00         MOV     R2,#0x0
   \   000021   7B00         MOV     R3,#0x0
   \   000023   8018         SJMP    ??ZDSecMgrMasterKeyStore_1
    648              {
    649                if ( ZDSecMgrMasterKeyData[index].ami == INVALID_NODE_ADDR )
    650                {
    651                  // store EXT address index
    652                  ZDSecMgrMasterKeyData[index].ami = ami;
    653          
    654                  entry = ZDSecMgrMasterKeyData[index].key;
    655          
    656                  if ( key != NULL )
    657                  {
    658                    osal_memcpy( entry, key,  SEC_KEY_LEN );
    659                  }
    660                  else
    661                  {
    662                    osal_memset( entry, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   000025                ; Setup parameters for call to function osal_memset
   \   000025   7C10         MOV     R4,#0x10
   \   000027   7D00         MOV     R5,#0x0
   \   000029   7900         MOV     R1,#0x0
   \   00002B   12....       LCALL   ??osal_memset?relay
    663                  }
    664          
    665                  // return successful results
    666                  status = ZSuccess;
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   00002E   75..00       MOV     ?V0 + 0,#0x0
    667          
    668                  // break from loop
    669                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   000031   7A03         MOV     R2,#0x3
   \   000033   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   000035   EA           MOV     A,R2
   \   000036   2401         ADD     A,#0x1
   \   000038   0A           INC     R2
   \   000039   EB           MOV     A,R3
   \   00003A   3400         ADDC    A,#0x0
   \   00003C   FB           MOV     R3,A
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   00003D   C3           CLR     C
   \   00003E   EA           MOV     A,R2
   \   00003F   9403         SUBB    A,#0x3
   \   000041   EB           MOV     A,R3
   \   000042   9400         SUBB    A,#0x0
   \   000044   5067         JNC     ??ZDSecMgrMasterKeyStore_0
   \   000046   EA           MOV     A,R2
   \   000047   F8           MOV     R0,A
   \   000048   EB           MOV     A,R3
   \   000049   F9           MOV     R1,A
   \   00004A   E8           MOV     A,R0
   \   00004B   75F012       MOV     B,#0x12
   \   00004E   A4           MUL     AB
   \   00004F   F8           MOV     R0,A
   \   000050   ACF0         MOV     R4,B
   \   000052   75F012       MOV     B,#0x12
   \   000055   E9           MOV     A,R1
   \   000056   A4           MUL     AB
   \   000057   2C           ADD     A,R4
   \   000058   F9           MOV     R1,A
   \   000059   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   28           ADD     A,R0
   \   00005E   FC           MOV     R4,A
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   39           ADDC    A,R1
   \   000062   FD           MOV     R5,A
   \   000063   8C82         MOV     DPL,R4
   \   000065   8D83         MOV     DPH,R5
   \   000067   E0           MOVX    A,@DPTR
   \   000068   64FE         XRL     A,#0xfe
   \   00006A   7003         JNZ     ??ZDSecMgrMasterKeyStore_5
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F4           CPL     A
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   00006F   70C4         JNZ     ??ZDSecMgrMasterKeyStore_4
   \   000071   8C82         MOV     DPL,R4
   \   000073   8D83         MOV     DPH,R5
   \   000075   E5..         MOV     A,?V0 + 4
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   E5..         MOV     A,?V0 + 5
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   28           ADD     A,R0
   \   000081   FA           MOV     R2,A
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   39           ADDC    A,R1
   \   000085   8A82         MOV     DPL,R2
   \   000087   F583         MOV     DPH,A
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   AA82         MOV     R2,DPL
   \   00008D   AB83         MOV     R3,DPH
   \   00008F   EE           MOV     A,R6
   \   000090   4F           ORL     A,R7
   \   000091   6092         JZ      ??ZDSecMgrMasterKeyStore_2
   \   000093                ; Setup parameters for call to function osal_memcpy
   \   000093   8E..         MOV     ?V0 + 0,R6
   \   000095   8F..         MOV     ?V0 + 1,R7
   \   000097   75..00       MOV     ?V0 + 2,#0x0
   \   00009A   78..         MOV     R0,#?V0 + 0
   \   00009C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00009F   7C10         MOV     R4,#0x10
   \   0000A1   7D00         MOV     R5,#0x0
   \   0000A3   12....       LCALL   ??osal_memcpy?relay
   \   0000A6   7403         MOV     A,#0x3
   \   0000A8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AB   8081         SJMP    ??ZDSecMgrMasterKeyStore_3
    670                }
    671              }
    672            }
    673          
    674            return status;
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   0000AD   A9..         MOV     R1,?V0 + 0
   \   0000AF   7F06         MOV     R7,#0x6
   \   0000B1   02....       LJMP    ?BANKED_LEAVE_XDATA
    675          }
    676          
    677          /******************************************************************************
    678           * @fn          ZDSecMgrEntryInit
    679           *
    680           * @brief       Initialize entry sub module
    681           *
    682           * @param       none
    683           *
    684           * @return      none
    685           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    686          void ZDSecMgrEntryInit( void )
   \                     ZDSecMgrEntryInit:
    687          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    688            uint16 size;
    689            uint16 index;
    690          
    691            // allocate entry data
    692            size = (short)( sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX );
    693          
    694            ZDSecMgrEntries = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A57         MOV     R2,#0x57
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00000E   EA           MOV     A,R2
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   EB           MOV     A,R3
   \   000012   F0           MOVX    @DPTR,A
    695          
    696            // initialize data
    697            if ( ZDSecMgrEntries != NULL )
   \   000013   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F8           MOV     R0,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F9           MOV     R1,A
   \   00001B   E8           MOV     A,R0
   \   00001C   49           ORL     A,R1
   \   00001D   603D         JZ      ??ZDSecMgrEntryInit_0
    698            {
    699              for( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001F   7800         MOV     R0,#0x0
   \   000021   7900         MOV     R1,#0x0
   \   000023   802E         SJMP    ??ZDSecMgrEntryInit_1
    700              {
    701                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_2:
   \   000025   E8           MOV     A,R0
   \   000026   FA           MOV     R2,A
   \   000027   E9           MOV     A,R1
   \   000028   FB           MOV     R3,A
   \   000029   EA           MOV     A,R2
   \   00002A   75F01D       MOV     B,#0x1d
   \   00002D   A4           MUL     AB
   \   00002E   FA           MOV     R2,A
   \   00002F   ACF0         MOV     R4,B
   \   000031   75F01D       MOV     B,#0x1d
   \   000034   EB           MOV     A,R3
   \   000035   A4           MUL     AB
   \   000036   2C           ADD     A,R4
   \   000037   FB           MOV     R3,A
   \   000038   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   2A           ADD     A,R2
   \   00003D   FC           MOV     R4,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   3B           ADDC    A,R3
   \   000041   8C82         MOV     DPL,R4
   \   000043   F583         MOV     DPH,A
   \   000045   74FE         MOV     A,#-0x2
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   04           INC     A
   \   00004A   F0           MOVX    @DPTR,A
    702              }
   \   00004B   E8           MOV     A,R0
   \   00004C   2401         ADD     A,#0x1
   \   00004E   08           INC     R0
   \   00004F   E9           MOV     A,R1
   \   000050   3400         ADDC    A,#0x0
   \   000052   F9           MOV     R1,A
   \                     ??ZDSecMgrEntryInit_1:
   \   000053   C3           CLR     C
   \   000054   E8           MOV     A,R0
   \   000055   9403         SUBB    A,#0x3
   \   000057   E9           MOV     A,R1
   \   000058   9400         SUBB    A,#0x0
   \   00005A   40C9         JC      ??ZDSecMgrEntryInit_2
    703            }
    704            ZDSecMgrRestoreFromNV();
   \                     ??ZDSecMgrEntryInit_0:
   \   00005C                ; Setup parameters for call to function ZDSecMgrRestoreFromNV
   \   00005C   12....       LCALL   ??ZDSecMgrRestoreFromNV?relay
    705          }
   \   00005F   D083         POP     DPH
   \   000061   D082         POP     DPL
   \   000063   02....       LJMP    ?BRET
    706          
    707          /******************************************************************************
    708           * @fn          ZDSecMgrEntryLookup
    709           *
    710           * @brief       Lookup entry index using specified NWK address.
    711           *
    712           * @param       nwkAddr - [in] NWK address
    713           * @param       entry   - [out] valid entry
    714           *
    715           * @return      ZStatus_t
    716           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    717          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    718          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    719            ZStatus_t      status;
    720            uint16         index;
    721            AddrMgrEntry_t addrMgrEntry;
    722          
    723          
    724            // initialize results
    725            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    726            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0 + 0,#-0x38
    727          
    728            // verify data is available
    729            if ( ZDSecMgrEntries != NULL )
   \   000019   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   E8           MOV     A,R0
   \   000022   49           ORL     A,R1
   \   000023   7003         JNZ     $+5
   \   000025   02....       LJMP    ??ZDSecMgrEntryLookup_0 & 0xFFFF
    730            {
    731              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   7402         MOV     A,#0x2
   \   000030   F0           MOVX    @DPTR,A
    732              addrMgrEntry.nwkAddr = nwkAddr;
   \   000031   14           DEC     A
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   EA           MOV     A,R2
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EB           MOV     A,R3
   \   000039   F0           MOVX    @DPTR,A
    733          
    734              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \   00003A                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   AA82         MOV     R2,DPL
   \   000042   AB83         MOV     R3,DPH
   \   000044   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000047   E9           MOV     A,R1
   \   000048   6401         XRL     A,#0x1
   \   00004A   705F         JNZ     ??ZDSecMgrEntryLookup_0
    735              {
    736                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00004C   7800         MOV     R0,#0x0
   \   00004E   7900         MOV     R1,#0x0
   \   000050   8050         SJMP    ??ZDSecMgrEntryLookup_1
    737                {
    738                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_2:
   \   000052   E8           MOV     A,R0
   \   000053   FA           MOV     R2,A
   \   000054   E9           MOV     A,R1
   \   000055   FB           MOV     R3,A
   \   000056   EA           MOV     A,R2
   \   000057   75F01D       MOV     B,#0x1d
   \   00005A   A4           MUL     AB
   \   00005B   FA           MOV     R2,A
   \   00005C   ACF0         MOV     R4,B
   \   00005E   75F01D       MOV     B,#0x1d
   \   000061   EB           MOV     A,R3
   \   000062   A4           MUL     AB
   \   000063   2C           ADD     A,R4
   \   000064   FB           MOV     R3,A
   \   000065   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000068   E0           MOVX    A,@DPTR
   \   000069   2A           ADD     A,R2
   \   00006A   FA           MOV     R2,A
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   3B           ADDC    A,R3
   \   00006E   FB           MOV     R3,A
   \   00006F   740B         MOV     A,#0xb
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   FC           MOV     R4,A
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   FD           MOV     R5,A
   \   000079   8A82         MOV     DPL,R2
   \   00007B   8B83         MOV     DPH,R3
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   6C           XRL     A,R4
   \   00007F   7003         JNZ     ??ZDSecMgrEntryLookup_3
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_3:
   \   000084   7014         JNZ     ??ZDSecMgrEntryLookup_4
    739                  {
    740                    // return successful results
    741                    *entry = &ZDSecMgrEntries[index];
   \   000086   EA           MOV     A,R2
   \   000087   F8           MOV     R0,A
   \   000088   EB           MOV     A,R3
   \   000089   F9           MOV     R1,A
   \   00008A   8E82         MOV     DPL,R6
   \   00008C   8F83         MOV     DPH,R7
   \   00008E   E8           MOV     A,R0
   \   00008F   F0           MOVX    @DPTR,A
   \   000090   A3           INC     DPTR
   \   000091   E9           MOV     A,R1
   \   000092   F0           MOVX    @DPTR,A
    742                    status = ZSuccess;
   \   000093   75..00       MOV     ?V0 + 0,#0x0
    743          
    744                    // break from loop
    745                    index = ZDSECMGR_ENTRY_MAX;
   \   000096   7803         MOV     R0,#0x3
   \   000098   7900         MOV     R1,#0x0
    746                  }
    747                }
   \                     ??ZDSecMgrEntryLookup_4:
   \   00009A   E8           MOV     A,R0
   \   00009B   2401         ADD     A,#0x1
   \   00009D   08           INC     R0
   \   00009E   E9           MOV     A,R1
   \   00009F   3400         ADDC    A,#0x0
   \   0000A1   F9           MOV     R1,A
   \                     ??ZDSecMgrEntryLookup_1:
   \   0000A2   C3           CLR     C
   \   0000A3   E8           MOV     A,R0
   \   0000A4   9403         SUBB    A,#0x3
   \   0000A6   E9           MOV     A,R1
   \   0000A7   9400         SUBB    A,#0x0
   \   0000A9   40A7         JC      ??ZDSecMgrEntryLookup_2
    748              }
    749            }
    750          
    751            return status;
   \                     ??ZDSecMgrEntryLookup_0:
   \   0000AB   A9..         MOV     R1,?V0 + 0
   \   0000AD   740D         MOV     A,#0xd
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B2   7F02         MOV     R7,#0x2
   \   0000B4   02....       LJMP    ?BANKED_LEAVE_XDATA
    752          }
    753          
    754          /******************************************************************************
    755           * @fn          ZDSecMgrEntryLookupAMI
    756           *
    757           * @brief       Lookup entry using specified address index
    758           *
    759           * @param       ami   - [in] Address Manager index
    760           * @param       entry - [out] valid entry
    761           *
    762           * @return      ZStatus_t
    763           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    764          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    765          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    766            ZStatus_t status;
    767            uint16    index;
    768          
    769          
    770            // initialize results
    771            *entry = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    772            status = ZNwkUnknownDevice;
   \   000011   75..C8       MOV     ?V0 + 0,#-0x38
    773          
    774            // verify data is available
    775            if ( ZDSecMgrEntries != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   6057         JZ      ??ZDSecMgrEntryLookupAMI_0
    776            {
    777              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000020   7800         MOV     R0,#0x0
   \   000022   7900         MOV     R1,#0x0
   \   000024   8048         SJMP    ??ZDSecMgrEntryLookupAMI_1
    778              {
    779                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000026   E8           MOV     A,R0
   \   000027   FA           MOV     R2,A
   \   000028   E9           MOV     A,R1
   \   000029   FB           MOV     R3,A
   \   00002A   EA           MOV     A,R2
   \   00002B   75F01D       MOV     B,#0x1d
   \   00002E   A4           MUL     AB
   \   00002F   FA           MOV     R2,A
   \   000030   85F0..       MOV     ?V0 + 1,B
   \   000033   75F01D       MOV     B,#0x1d
   \   000036   EB           MOV     A,R3
   \   000037   A4           MUL     AB
   \   000038   25..         ADD     A,?V0 + 1
   \   00003A   FB           MOV     R3,A
   \   00003B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   2A           ADD     A,R2
   \   000040   FA           MOV     R2,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   3B           ADDC    A,R3
   \   000044   FB           MOV     R3,A
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6E           XRL     A,R6
   \   00004B   7003         JNZ     ??ZDSecMgrEntryLookupAMI_3
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   6F           XRL     A,R7
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000050   7014         JNZ     ??ZDSecMgrEntryLookupAMI_4
    780                {
    781                  // return successful results
    782                  *entry = &ZDSecMgrEntries[index];
   \   000052   EA           MOV     A,R2
   \   000053   F8           MOV     R0,A
   \   000054   EB           MOV     A,R3
   \   000055   F9           MOV     R1,A
   \   000056   8C82         MOV     DPL,R4
   \   000058   8D83         MOV     DPH,R5
   \   00005A   E8           MOV     A,R0
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   E9           MOV     A,R1
   \   00005E   F0           MOVX    @DPTR,A
    783                  status = ZSuccess;
   \   00005F   75..00       MOV     ?V0 + 0,#0x0
    784          
    785                  // break from loop
    786                  index = ZDSECMGR_ENTRY_MAX;
   \   000062   7803         MOV     R0,#0x3
   \   000064   7900         MOV     R1,#0x0
    787                }
    788              }
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   000066   E8           MOV     A,R0
   \   000067   2401         ADD     A,#0x1
   \   000069   08           INC     R0
   \   00006A   E9           MOV     A,R1
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F9           MOV     R1,A
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   00006E   C3           CLR     C
   \   00006F   E8           MOV     A,R0
   \   000070   9403         SUBB    A,#0x3
   \   000072   E9           MOV     A,R1
   \   000073   9400         SUBB    A,#0x0
   \   000075   40AF         JC      ??ZDSecMgrEntryLookupAMI_2
    789            }
    790          
    791            return status;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000077   A9..         MOV     R1,?V0 + 0
   \   000079   7F02         MOV     R7,#0x2
   \   00007B   02....       LJMP    ?BANKED_LEAVE_XDATA
    792          }
    793          
    794          /******************************************************************************
    795           * @fn          ZDSecMgrEntryLookupExt
    796           *
    797           * @brief       Lookup entry index using specified EXT address.
    798           *
    799           * @param       extAddr - [in] EXT address
    800           * @param       entry   - [out] valid entry
    801           *
    802           * @return      ZStatus_t
    803           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    804          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    805          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    806            ZStatus_t status;
    807            uint16    ami;
    808          
    809          
    810            // initialize results
    811            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    812            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0 + 0,#-0x38
    813          
    814            // lookup address index
    815            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   AC82         MOV     R4,DPL
   \   000021   AD83         MOV     R5,DPH
   \   000023   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000026   E9           MOV     A,R1
   \   000027   7015         JNZ     ??ZDSecMgrEntryLookupExt_0
    816            {
    817              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000029                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000029   EE           MOV     A,R6
   \   00002A   FC           MOV     R4,A
   \   00002B   EF           MOV     A,R7
   \   00002C   FD           MOV     R5,A
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FA           MOV     R2,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   00003B   E9           MOV     A,R1
   \   00003C   F5..         MOV     ?V0 + 0,A
    818            }
    819          
    820            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   00003E   A9..         MOV     R1,?V0 + 0
   \   000040   7402         MOV     A,#0x2
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
   \   000045   7F01         MOV     R7,#0x1
   \   000047   02....       LJMP    ?BANKED_LEAVE_XDATA
    821          }
    822          
    823          /******************************************************************************
    824           * @fn          ZDSecMgrEntryFree
    825           *
    826           * @brief       Free entry.
    827           *
    828           * @param       entry - [in] valid entry
    829           *
    830           * @return      ZStatus_t
    831           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    832          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    833          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    834            entry->ami = INVALID_NODE_ADDR;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   74FE         MOV     A,#-0x2
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   04           INC     A
   \   00000D   F0           MOVX    @DPTR,A
    835          }
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
    836          
    837          /******************************************************************************
    838           * @fn          ZDSecMgrEntryNew
    839           *
    840           * @brief       Get a new entry.
    841           *
    842           * @param       entry - [out] valid entry
    843           *
    844           * @return      ZStatus_t
    845           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    846          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    847          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    848            ZStatus_t status;
    849            uint16    index;
    850          
    851          
    852            // initialize results
    853            *entry = NULL;
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    854            status = ZNwkUnknownDevice;
   \   000011   75..C8       MOV     ?V0 + 0,#-0x38
    855          
    856            // verify data is available
    857            if ( ZDSecMgrEntries != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   606B         JZ      ??ZDSecMgrEntryNew_0
    858            {
    859              // find available entry
    860              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000020   7A00         MOV     R2,#0x0
   \   000022   7B00         MOV     R3,#0x0
   \   000024   805C         SJMP    ??ZDSecMgrEntryNew_1
    861              {
    862                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_2:
   \   000026   EA           MOV     A,R2
   \   000027   F8           MOV     R0,A
   \   000028   EB           MOV     A,R3
   \   000029   F9           MOV     R1,A
   \   00002A   E8           MOV     A,R0
   \   00002B   75F01D       MOV     B,#0x1d
   \   00002E   A4           MUL     AB
   \   00002F   F8           MOV     R0,A
   \   000030   ACF0         MOV     R4,B
   \   000032   75F01D       MOV     B,#0x1d
   \   000035   E9           MOV     A,R1
   \   000036   A4           MUL     AB
   \   000037   2C           ADD     A,R4
   \   000038   F9           MOV     R1,A
   \   000039   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   28           ADD     A,R0
   \   00003E   FC           MOV     R4,A
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   39           ADDC    A,R1
   \   000042   FD           MOV     R5,A
   \   000043   8C82         MOV     DPL,R4
   \   000045   8D83         MOV     DPH,R5
   \   000047   E0           MOVX    A,@DPTR
   \   000048   64FE         XRL     A,#0xfe
   \   00004A   7003         JNZ     ??ZDSecMgrEntryNew_3
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F4           CPL     A
   \                     ??ZDSecMgrEntryNew_3:
   \   00004F   7029         JNZ     ??ZDSecMgrEntryNew_4
    863                {
    864                  // return successful result
    865                  *entry = &ZDSecMgrEntries[index];
   \   000051   EC           MOV     A,R4
   \   000052   FA           MOV     R2,A
   \   000053   ED           MOV     A,R5
   \   000054   FB           MOV     R3,A
   \   000055   8E82         MOV     DPL,R6
   \   000057   8F83         MOV     DPH,R7
   \   000059   EA           MOV     A,R2
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   A3           INC     DPTR
   \   00005C   EB           MOV     A,R3
   \   00005D   F0           MOVX    @DPTR,A
    866                  status = ZSuccess;
   \   00005E   75..00       MOV     ?V0 + 0,#0x0
    867          
    868                  // Set the authentication option to default
    869                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000061   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000064   E0           MOVX    A,@DPTR
   \   000065   28           ADD     A,R0
   \   000066   F8           MOV     R0,A
   \   000067   A3           INC     DPTR
   \   000068   E0           MOVX    A,@DPTR
   \   000069   39           ADDC    A,R1
   \   00006A   F9           MOV     R1,A
   \   00006B   E8           MOV     A,R0
   \   00006C   241C         ADD     A,#0x1c
   \   00006E   F582         MOV     DPL,A
   \   000070   E9           MOV     A,R1
   \   000071   3400         ADDC    A,#0x0
   \   000073   F583         MOV     DPH,A
   \   000075   E4           CLR     A
   \   000076   F0           MOVX    @DPTR,A
    870          
    871                  // break from loop
    872                  index = ZDSECMGR_ENTRY_MAX;
   \   000077   7A03         MOV     R2,#0x3
   \   000079   FB           MOV     R3,A
    873                }
    874              }
   \                     ??ZDSecMgrEntryNew_4:
   \   00007A   EA           MOV     A,R2
   \   00007B   2401         ADD     A,#0x1
   \   00007D   0A           INC     R2
   \   00007E   EB           MOV     A,R3
   \   00007F   3400         ADDC    A,#0x0
   \   000081   FB           MOV     R3,A
   \                     ??ZDSecMgrEntryNew_1:
   \   000082   C3           CLR     C
   \   000083   EA           MOV     A,R2
   \   000084   9403         SUBB    A,#0x3
   \   000086   EB           MOV     A,R3
   \   000087   9400         SUBB    A,#0x0
   \   000089   409B         JC      ??ZDSecMgrEntryNew_2
    875            }
    876          
    877            return status;
   \                     ??ZDSecMgrEntryNew_0:
   \   00008B   A9..         MOV     R1,?V0 + 0
   \   00008D   7F02         MOV     R7,#0x2
   \   00008F   02....       LJMP    ?BANKED_LEAVE_XDATA
    878          }
    879          
    880          /******************************************************************************
    881           * @fn          ZDSecMgrCtrlInit
    882           *
    883           * @brief       Initialize control sub module
    884           *
    885           * @param       none
    886           *
    887           * @return      none
    888           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    889          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    890          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    891            uint16 size;
    892            uint16 index;
    893          
    894            // allocate entry data
    895            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    896          
    897            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV     R2,#0x15
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000E   EA           MOV     A,R2
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   EB           MOV     A,R3
   \   000012   F0           MOVX    @DPTR,A
    898          
    899            // initialize data
    900            if ( ZDSecMgrCtrlData != NULL )
   \   000013   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F8           MOV     R0,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F9           MOV     R1,A
   \   00001B   E8           MOV     A,R0
   \   00001C   49           ORL     A,R1
   \   00001D   603E         JZ      ??ZDSecMgrCtrlInit_0
    901            {
    902              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001F   7800         MOV     R0,#0x0
   \   000021   7900         MOV     R1,#0x0
   \   000023   802F         SJMP    ??ZDSecMgrCtrlInit_1
    903              {
    904                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_2:
   \   000025   E8           MOV     A,R0
   \   000026   FA           MOV     R2,A
   \   000027   E9           MOV     A,R1
   \   000028   FB           MOV     R3,A
   \   000029   EA           MOV     A,R2
   \   00002A   75F007       MOV     B,#0x7
   \   00002D   A4           MUL     AB
   \   00002E   FA           MOV     R2,A
   \   00002F   ACF0         MOV     R4,B
   \   000031   75F007       MOV     B,#0x7
   \   000034   EB           MOV     A,R3
   \   000035   A4           MUL     AB
   \   000036   2C           ADD     A,R4
   \   000037   FB           MOV     R3,A
   \   000038   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   2A           ADD     A,R2
   \   00003D   FC           MOV     R4,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   3B           ADDC    A,R3
   \   000041   8C82         MOV     DPL,R4
   \   000043   F583         MOV     DPH,A
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
    905              }
   \   00004C   E8           MOV     A,R0
   \   00004D   2401         ADD     A,#0x1
   \   00004F   08           INC     R0
   \   000050   E9           MOV     A,R1
   \   000051   3400         ADDC    A,#0x0
   \   000053   F9           MOV     R1,A
   \                     ??ZDSecMgrCtrlInit_1:
   \   000054   C3           CLR     C
   \   000055   E8           MOV     A,R0
   \   000056   9403         SUBB    A,#0x3
   \   000058   E9           MOV     A,R1
   \   000059   9400         SUBB    A,#0x0
   \   00005B   40C8         JC      ??ZDSecMgrCtrlInit_2
    906            }
    907          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   00005D   D083         POP     DPH
   \   00005F   D082         POP     DPL
   \   000061   02....       LJMP    ?BRET
    908          
    909          /******************************************************************************
    910           * @fn          ZDSecMgrCtrlRelease
    911           *
    912           * @brief       Release control data.
    913           *
    914           * @param       ctrl - [in] valid control data
    915           *
    916           * @return      none
    917           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    918          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    919          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    920            // should always be enough entry control data
    921            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
    922          }
   \   00000F   D083         POP     DPH
   \   000011   D082         POP     DPL
   \   000013   02....       LJMP    ?BRET
    923          
    924          /******************************************************************************
    925           * @fn          ZDSecMgrCtrlLookup
    926           *
    927           * @brief       Lookup control data.
    928           *
    929           * @param       entry - [in] valid entry data
    930           * @param       ctrl  - [out] control data - NULL if not found
    931           *
    932           * @return      none
    933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    934          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    935          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    936            uint16 index;
    937          
    938          
    939            // initialize search results
    940            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    941          
    942            // verify data is available
    943            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   E8           MOV     A,R0
   \   00001A   49           ORL     A,R1
   \   00001B   6068         JZ      ??ZDSecMgrCtrlLookup_0
    944            {
    945              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001D   7800         MOV     R0,#0x0
   \   00001F   7900         MOV     R1,#0x0
   \   000021   8059         SJMP    ??ZDSecMgrCtrlLookup_1
    946              {
    947                // make sure control data is in use
    948                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_2:
   \   000023   E8           MOV     A,R0
   \   000024   FA           MOV     R2,A
   \   000025   E9           MOV     A,R1
   \   000026   FB           MOV     R3,A
   \   000027   EA           MOV     A,R2
   \   000028   75F007       MOV     B,#0x7
   \   00002B   A4           MUL     AB
   \   00002C   FA           MOV     R2,A
   \   00002D   85F0..       MOV     ?V0 + 0,B
   \   000030   75F007       MOV     B,#0x7
   \   000033   EB           MOV     A,R3
   \   000034   A4           MUL     AB
   \   000035   25..         ADD     A,?V0 + 0
   \   000037   FB           MOV     R3,A
   \   000038   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   2A           ADD     A,R2
   \   00003D   FA           MOV     R2,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   3B           ADDC    A,R3
   \   000041   FB           MOV     R3,A
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   6026         JZ      ??ZDSecMgrCtrlLookup_3
    949                {
    950                  // check for entry match
    951                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F5..         MOV     ?V0 + 0,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F5..         MOV     ?V0 + 1,A
   \   000059   EE           MOV     A,R6
   \   00005A   65..         XRL     A,?V0 + 0
   \   00005C   7003         JNZ     ??ZDSecMgrCtrlLookup_4
   \   00005E   EF           MOV     A,R7
   \   00005F   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   000061   7011         JNZ     ??ZDSecMgrCtrlLookup_3
    952                  {
    953                    // return this control data
    954                    *ctrl = &ZDSecMgrCtrlData[index];
   \   000063   EA           MOV     A,R2
   \   000064   F8           MOV     R0,A
   \   000065   EB           MOV     A,R3
   \   000066   F9           MOV     R1,A
   \   000067   8C82         MOV     DPL,R4
   \   000069   8D83         MOV     DPH,R5
   \   00006B   E8           MOV     A,R0
   \   00006C   F0           MOVX    @DPTR,A
   \   00006D   A3           INC     DPTR
   \   00006E   E9           MOV     A,R1
   \   00006F   F0           MOVX    @DPTR,A
    955          
    956                    // break from loop
    957                    index = ZDSECMGR_CTRL_MAX;
   \   000070   7803         MOV     R0,#0x3
   \   000072   7900         MOV     R1,#0x0
    958                  }
    959                }
    960              }
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000074   E8           MOV     A,R0
   \   000075   2401         ADD     A,#0x1
   \   000077   08           INC     R0
   \   000078   E9           MOV     A,R1
   \   000079   3400         ADDC    A,#0x0
   \   00007B   F9           MOV     R1,A
   \                     ??ZDSecMgrCtrlLookup_1:
   \   00007C   C3           CLR     C
   \   00007D   E8           MOV     A,R0
   \   00007E   9403         SUBB    A,#0x3
   \   000080   E9           MOV     A,R1
   \   000081   9400         SUBB    A,#0x0
   \   000083   409E         JC      ??ZDSecMgrCtrlLookup_2
    961            }
    962          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   000085   7F02         MOV     R7,#0x2
   \   000087   02....       LJMP    ?BANKED_LEAVE_XDATA
    963          
    964          /******************************************************************************
    965           * @fn          ZDSecMgrCtrlSet
    966           *
    967           * @brief       Set control data.
    968           *
    969           * @param       device - [in] valid device data
    970           * @param       entry  - [in] valid entry data
    971           * @param       ctrl   - [in] valid control data
    972           *
    973           * @return      none
    974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    975          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
    976                                ZDSecMgrEntry_t*  entry,
    977                                ZDSecMgrCtrl_t*   ctrl )
    978          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
    979            // set control date
    980            ctrl->parentAddr = device->parentAddr;
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
    981            ctrl->secure     = device->secure;
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   8882         MOV     DPL,R0
   \   000034   8983         MOV     DPH,R1
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   F0           MOVX    @DPTR,A
    982            ctrl->entry      = entry;
   \   00003B   8882         MOV     DPL,R0
   \   00003D   8983         MOV     DPH,R1
   \   00003F   EC           MOV     A,R4
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   ED           MOV     A,R5
   \   000043   F0           MOVX    @DPTR,A
    983            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \   000044   8882         MOV     DPL,R0
   \   000046   8983         MOV     DPH,R1
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   7401         MOV     A,#0x1
   \   00004F   F0           MOVX    @DPTR,A
    984            ctrl->cntr       = 0;
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   E4           CLR     A
   \   00005B   F0           MOVX    @DPTR,A
    985          
    986            // set device pointer
    987            device->ctrl = ctrl;
   \   00005C   8A82         MOV     DPL,R2
   \   00005E   8B83         MOV     DPH,R3
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   E8           MOV     A,R0
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   E9           MOV     A,R1
   \   00006C   F0           MOVX    @DPTR,A
    988          }
   \   00006D   7F01         MOV     R7,#0x1
   \   00006F   02....       LJMP    ?BANKED_LEAVE_XDATA
    989          
    990          /******************************************************************************
    991           * @fn          ZDSecMgrCtrlAdd
    992           *
    993           * @brief       Add control data.
    994           *
    995           * @param       device - [in] valid device data
    996           * @param       entry  - [in] valid entry data
    997           *
    998           * @return      ZStatus_t
    999           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1000          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1001          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1002            ZStatus_t status;
   1003            uint16    index;
   1004          
   1005          
   1006            // initialize results
   1007            status = ZNwkUnknownDevice;
   \   00000D   7CC8         MOV     R4,#-0x38
   1008          
   1009            // verify data is available
   1010            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   E8           MOV     A,R0
   \   000018   49           ORL     A,R1
   \   000019   605F         JZ      ??ZDSecMgrCtrlAdd_0
   1011            {
   1012              // look for an empty slot
   1013              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
   \   00001F   8050         SJMP    ??ZDSecMgrCtrlAdd_1
   1014              {
   1015                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_2:
   \   000021   E8           MOV     A,R0
   \   000022   FA           MOV     R2,A
   \   000023   E9           MOV     A,R1
   \   000024   FB           MOV     R3,A
   \   000025   EA           MOV     A,R2
   \   000026   75F007       MOV     B,#0x7
   \   000029   A4           MUL     AB
   \   00002A   FA           MOV     R2,A
   \   00002B   ADF0         MOV     R5,B
   \   00002D   75F007       MOV     B,#0x7
   \   000030   EB           MOV     A,R3
   \   000031   A4           MUL     AB
   \   000032   2D           ADD     A,R5
   \   000033   FB           MOV     R3,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000037   E0           MOVX    A,@DPTR
   \   000038   2A           ADD     A,R2
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   3B           ADDC    A,R3
   \   00003D   FB           MOV     R3,A
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   701F         JNZ     ??ZDSecMgrCtrlAdd_3
   1016                {
   1017                  // return successful results
   1018                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   00004A                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   00004A   8A..         MOV     ?V0 + 2,R2
   \   00004C   8B..         MOV     ?V0 + 3,R3
   \   00004E   78..         MOV     R0,#?V0 + 2
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   EE           MOV     A,R6
   \   000054   FC           MOV     R4,A
   \   000055   EF           MOV     A,R7
   \   000056   FD           MOV     R5,A
   \   000057   AA..         MOV     R2,?V0 + 0
   \   000059   AB..         MOV     R3,?V0 + 1
   \   00005B   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   00005E   7402         MOV     A,#0x2
   \   000060   12....       LCALL   ?DEALLOC_XSTACK8
   1019          
   1020                  status = ZSuccess;
   \   000063   7C00         MOV     R4,#0x0
   1021          
   1022                  // break from loop
   1023                  index = ZDSECMGR_CTRL_MAX;
   \   000065   7803         MOV     R0,#0x3
   \   000067   7900         MOV     R1,#0x0
   1024                }
   1025              }
   \                     ??ZDSecMgrCtrlAdd_3:
   \   000069   E8           MOV     A,R0
   \   00006A   2401         ADD     A,#0x1
   \   00006C   08           INC     R0
   \   00006D   E9           MOV     A,R1
   \   00006E   3400         ADDC    A,#0x0
   \   000070   F9           MOV     R1,A
   \                     ??ZDSecMgrCtrlAdd_1:
   \   000071   C3           CLR     C
   \   000072   E8           MOV     A,R0
   \   000073   9403         SUBB    A,#0x3
   \   000075   E9           MOV     A,R1
   \   000076   9400         SUBB    A,#0x0
   \   000078   40A7         JC      ??ZDSecMgrCtrlAdd_2
   1026            }
   1027          
   1028            return status;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   00007A   EC           MOV     A,R4
   \   00007B   F9           MOV     R1,A
   \   00007C   7F04         MOV     R7,#0x4
   \   00007E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1029          }
   1030          
   1031          /******************************************************************************
   1032           * @fn          ZDSecMgrCtrlTerm
   1033           *
   1034           * @brief       Terminate device control.
   1035           *
   1036           * @param       entry - [in] valid entry data
   1037           *
   1038           * @return      none
   1039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1040          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1041          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1042            ZDSecMgrCtrl_t* ctrl;
   1043          
   1044            // remove device from control data
   1045            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1046          
   1047            if ( ctrl != NULL )
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   E8           MOV     A,R0
   \   000022   49           ORL     A,R1
   \   000023   600E         JZ      ??ZDSecMgrCtrlTerm_0
   1048            {
   1049              ZDSecMgrCtrlRelease ( ctrl );
   \   000025                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   FA           MOV     R2,A
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   FB           MOV     R3,A
   \   000030   12....       LCALL   ??ZDSecMgrCtrlRelease?relay
   1050            }
   1051          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
   \   000038   D083         POP     DPH
   \   00003A   D082         POP     DPL
   \   00003C   02....       LJMP    ?BRET
   1052          
   1053          /******************************************************************************
   1054           * @fn          ZDSecMgrCtrlReset
   1055           *
   1056           * @brief       Reset control data.
   1057           *
   1058           * @param       device - [in] valid device data
   1059           * @param       entry  - [in] valid entry data
   1060           *
   1061           * @return      ZStatus_t
   1062           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1063          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1064          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1065            ZStatus_t       status;
   1066            ZDSecMgrCtrl_t* ctrl;
   1067          
   1068          
   1069            // initialize results
   1070            status = ZNwkUnknownDevice;
   1071          
   1072            // look for a match for the entry
   1073            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1074          
   1075            if ( ctrl != NULL )
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F9           MOV     R1,A
   \   00002E   E8           MOV     A,R0
   \   00002F   49           ORL     A,R1
   \   000030   601D         JZ      ??ZDSecMgrCtrlReset_0
   1076            {
   1077              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000032                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003B   EE           MOV     A,R6
   \   00003C   FC           MOV     R4,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FD           MOV     R5,A
   \   00003F   AA..         MOV     R2,?V0 + 0
   \   000041   AB..         MOV     R3,?V0 + 1
   \   000043   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   000046   7402         MOV     A,#0x2
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   1078          
   1079              status = ZSuccess;
   \   00004B   7900         MOV     R1,#0x0
   \   00004D   800B         SJMP    ??ZDSecMgrCtrlReset_1
   1080            }
   1081            else
   1082            {
   1083              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   00004F                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   00004F   EE           MOV     A,R6
   \   000050   FC           MOV     R4,A
   \   000051   EF           MOV     A,R7
   \   000052   FD           MOV     R5,A
   \   000053   AA..         MOV     R2,?V0 + 0
   \   000055   AB..         MOV     R3,?V0 + 1
   \   000057   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   1084            }
   1085          
   1086            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   00005A   7402         MOV     A,#0x2
   \   00005C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005F   7F02         MOV     R7,#0x2
   \   000061   02....       LJMP    ?BANKED_LEAVE_XDATA
   1087          }
   1088          
   1089          /******************************************************************************
   1090           * @fn          ZDSecMgrMasterKeyLoad
   1091           *
   1092           * @brief       Load the MASTER key for device with specified EXT
   1093           *              address.
   1094           *
   1095           * @param       extAddr - [in] EXT address of device
   1096           * @param       key     - [in] MASTER key shared with device
   1097           *
   1098           * @return      ZStatus_t
   1099           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1100          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1101          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1102            ZStatus_t status;
   1103            uint8*    loaded;
   1104            uint16    ami;
   1105          
   1106          
   1107            // set status based on policy
   1108            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   1109          
   1110            if ( status == ZSuccess )
   \   00001E   7053         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1111            {
   1112              // get the address index
   1113              if ( ZDSecMgrMasterKeyLookup( ami, &loaded ) == ZSuccess )
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   AC82         MOV     R4,DPL
   \   000027   AD83         MOV     R5,DPH
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FB           MOV     R3,A
   \   000034   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000037   E9           MOV     A,R1
   \   000038   7024         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1114              {
   1115                // overwrite old key
   1116                osal_memcpy( loaded, key, SEC_KEY_LEN );
   \   00003A                ; Setup parameters for call to function osal_memcpy
   \   00003A   8E..         MOV     ?V0 + 4,R6
   \   00003C   8F..         MOV     ?V0 + 5,R7
   \   00003E   75..00       MOV     ?V0 + 6,#0x0
   \   000041   78..         MOV     R0,#?V0 + 4
   \   000043   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000046   7C10         MOV     R4,#0x10
   \   000048   7D00         MOV     R5,#0x0
   \   00004A   7405         MOV     A,#0x5
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   FA           MOV     R2,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   FB           MOV     R3,A
   \   000054   12....       LCALL   ??osal_memcpy?relay
   \   000057   7403         MOV     A,#0x3
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   8015         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1117              }
   1118              else
   1119              {
   1120                // store new key -- NULL will zero key
   1121                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   00005E                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00005E   EE           MOV     A,R6
   \   00005F   FC           MOV     R4,A
   \   000060   EF           MOV     A,R7
   \   000061   FD           MOV     R5,A
   \   000062   85..82       MOV     DPL,?XSP + 0
   \   000065   85..83       MOV     DPH,?XSP + 1
   \   000068   E0           MOVX    A,@DPTR
   \   000069   FA           MOV     R2,A
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   FB           MOV     R3,A
   \   00006D   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   000070   E9           MOV     A,R1
   \   000071   F5..         MOV     ?V0 + 0,A
   1122              }
   1123            }
   1124          
   1125            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000073   A9..         MOV     R1,?V0 + 0
   \   000075   7404         MOV     A,#0x4
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007A   7F07         MOV     R7,#0x7
   \   00007C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1126          }
   1127          
   1128          /******************************************************************************
   1129           * @fn          ZDSecMgrAppKeyGet
   1130           *
   1131           * @brief       get an APP key - option APP(MASTER or LINK) key
   1132           *
   1133           * @param       initNwkAddr - [in] NWK address of initiator device
   1134           * @param       initExtAddr - [in] EXT address of initiator device
   1135           * @param       partNwkAddr - [in] NWK address of partner device
   1136           * @param       partExtAddr - [in] EXT address of partner device
   1137           * @param       key         - [out] APP(MASTER or LINK) key
   1138           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1139           *
   1140           * @return      ZStatus_t
   1141           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1142          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1143                                                           // to KEY_TYPE_APP_LINK since
   1144                                                           // only specific requirement
   1145                                                           // right now comes from SE profile
   1146          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1147          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1148                                       uint8*  initExtAddr,
   1149                                       uint16  partNwkAddr,
   1150                                       uint8*  partExtAddr,
   1151                                       uint8** key,
   1152                                       uint8*  keyType )
   1153          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   740D         MOV     A,#0xd
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   740F         MOV     A,#0xf
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   FE           MOV     R6,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FF           MOV     R7,A
   1154            // Intentionally unreferenced parameters
   1155            (void)initNwkAddr;
   1156            (void)initExtAddr;
   1157            (void)partNwkAddr;
   1158            (void)partExtAddr;
   1159            
   1160            //---------------------------------------------------------------------------
   1161            // note:
   1162            // should use a robust mechanism to generate keys, for example
   1163            // combine EXT addresses and call a hash function
   1164            //---------------------------------------------------------------------------
   1165            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000019                ; Setup parameters for call to function SSP_GetTrueRand
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   FA           MOV     R2,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   FB           MOV     R3,A
   \   000022   7910         MOV     R1,#0x10
   \   000024   12....       LCALL   ??SSP_GetTrueRand?relay
   1166          
   1167            *keyType = ZDSecMgrAppKeyType;
   \   000027   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   F0           MOVX    @DPTR,A
   1168          
   1169            return ZSuccess;
   \   000030   7900         MOV     R1,#0x0
   \   000032   7F01         MOV     R7,#0x1
   \   000034   02....       LJMP    ?BANKED_LEAVE_XDATA
   1170          }
   1171          
   1172          /******************************************************************************
   1173           * @fn          ZDSecMgrAppKeyReq
   1174           *
   1175           * @brief       Process request for APP key between two devices.
   1176           *
   1177           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1178           *
   1179           * @return      none
   1180           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1181          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1182          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1183            APSME_TransportKeyReq_t req;
   1184            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1185            uint16                  partNwkAddr;
   1186            uint8                   key[SEC_KEY_LEN];
   1187          
   1188          
   1189            // validate initiator and partner
   1190            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1191                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   EE           MOV     A,R6
   \   00000F   2405         ADD     A,#0x5
   \   000011   F5..         MOV     ?V0 + 0,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   AC82         MOV     R4,DPL
   \   000020   AD83         MOV     R5,DPH
   \   000022   AA..         MOV     R2,?V0 + 0
   \   000024   FB           MOV     R3,A
   \   000025   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000028   E9           MOV     A,R1
   \   000029   6401         XRL     A,#0x1
   \   00002B   6003         JZ      $+5
   \   00002D   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000030   EE           MOV     A,R6
   \   000031   2402         ADD     A,#0x2
   \   000033   0E           INC     R6
   \   000034   0E           INC     R6
   \   000035   EF           MOV     A,R7
   \   000036   3400         ADDC    A,#0x0
   \   000038   FF           MOV     R7,A
   \   000039                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000039   740F         MOV     A,#0xf
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   AC82         MOV     R4,DPL
   \   000040   AD83         MOV     R5,DPH
   \   000042   8E82         MOV     DPL,R6
   \   000044   8F83         MOV     DPH,R7
   \   000046   E0           MOVX    A,@DPTR
   \   000047   FA           MOV     R2,A
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   FB           MOV     R3,A
   \   00004B   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   00004E   E9           MOV     A,R1
   \   00004F   6401         XRL     A,#0x1
   \   000051   6003         JZ      $+5
   \   000053   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1192            {
   1193              // point the key to some memory
   1194              req.key = key;
   \   000056   7417         MOV     A,#0x17
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   A882         MOV     R0,DPL
   \   00005D   A983         MOV     R1,DPH
   \   00005F   7406         MOV     A,#0x6
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   E8           MOV     A,R0
   \   000065   F0           MOVX    @DPTR,A
   \   000066   A3           INC     DPTR
   \   000067   E9           MOV     A,R1
   \   000068   F0           MOVX    @DPTR,A
   1195          
   1196              // get an APP key - option APP (MASTER or LINK) key
   1197              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1198                                      initExtAddr,
   1199                                      partNwkAddr,
   1200                                      ind->partExtAddr,
   1201                                      &req.key,
   1202                                      &req.keyType ) == ZSuccess )
   \   000069                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   000069   7404         MOV     A,#0x4
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   8582..       MOV     ?V0 + 2,DPL
   \   000071   8583..       MOV     ?V0 + 3,DPH
   \   000074   78..         MOV     R0,#?V0 + 2
   \   000076   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000079   7408         MOV     A,#0x8
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   8582..       MOV     ?V0 + 2,DPL
   \   000081   8583..       MOV     ?V0 + 3,DPH
   \   000084   78..         MOV     R0,#?V0 + 2
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008E   7406         MOV     A,#0x6
   \   000090   12....       LCALL   ?XSTACK_DISP0_8
   \   000093   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000096   7417         MOV     A,#0x17
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   AC82         MOV     R4,DPL
   \   00009D   AD83         MOV     R5,DPH
   \   00009F   8E82         MOV     DPL,R6
   \   0000A1   8F83         MOV     DPH,R7
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   FA           MOV     R2,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   FB           MOV     R3,A
   \   0000A8   12....       LCALL   ??ZDSecMgrAppKeyGet?relay
   \   0000AB   7408         MOV     A,#0x8
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B0   E9           MOV     A,R1
   \   0000B1   6003         JZ      $+5
   \   0000B3   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1203              {
   1204                // always secure
   1205                req.nwkSecure = TRUE;
   \   0000B6   740C         MOV     A,#0xc
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   7401         MOV     A,#0x1
   \   0000BD   F0           MOVX    @DPTR,A
   1206                req.apsSecure = TRUE;
   \   0000BE   740B         MOV     A,#0xb
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   7401         MOV     A,#0x1
   \   0000C5   F0           MOVX    @DPTR,A
   1207                req.tunnel    = NULL;
   \   0000C6   740D         MOV     A,#0xd
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   E4           CLR     A
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   F0           MOVX    @DPTR,A
   1208          
   1209                // send key to initiator device
   1210                req.dstAddr   = ind->srcAddr;
   \   0000CF   8E82         MOV     DPL,R6
   \   0000D1   8F83         MOV     DPH,R7
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   F8           MOV     R0,A
   \   0000D5   A3           INC     DPTR
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   F9           MOV     R1,A
   \   0000D8   7402         MOV     A,#0x2
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   E8           MOV     A,R0
   \   0000DE   F0           MOVX    @DPTR,A
   \   0000DF   A3           INC     DPTR
   \   0000E0   E9           MOV     A,R1
   \   0000E1   F0           MOVX    @DPTR,A
   1211                req.extAddr   = ind->partExtAddr;
   \   0000E2   7408         MOV     A,#0x8
   \   0000E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E7   E5..         MOV     A,?V0 + 0
   \   0000E9   F0           MOVX    @DPTR,A
   \   0000EA   A3           INC     DPTR
   \   0000EB   E5..         MOV     A,?V0 + 1
   \   0000ED   F0           MOVX    @DPTR,A
   1212                req.initiator = TRUE;
   \   0000EE   740A         MOV     A,#0xa
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   7401         MOV     A,#0x1
   \   0000F5   F0           MOVX    @DPTR,A
   1213                APSME_TransportKeyReq( &req );
   \   0000F6                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000F6   04           INC     A
   \   0000F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FA   AA82         MOV     R2,DPL
   \   0000FC   AB83         MOV     R3,DPH
   \   0000FE   12....       LCALL   ??APSME_TransportKeyReq?relay
   1214          
   1215                // send key to partner device
   1216                req.dstAddr   = partNwkAddr;
   \   000101   85..82       MOV     DPL,?XSP + 0
   \   000104   85..83       MOV     DPH,?XSP + 1
   \   000107   E0           MOVX    A,@DPTR
   \   000108   F8           MOV     R0,A
   \   000109   A3           INC     DPTR
   \   00010A   E0           MOVX    A,@DPTR
   \   00010B   F9           MOV     R1,A
   \   00010C   7402         MOV     A,#0x2
   \   00010E   12....       LCALL   ?XSTACK_DISP0_8
   \   000111   E8           MOV     A,R0
   \   000112   F0           MOVX    @DPTR,A
   \   000113   A3           INC     DPTR
   \   000114   E9           MOV     A,R1
   \   000115   F0           MOVX    @DPTR,A
   1217                req.extAddr   = initExtAddr;
   \   000116   740F         MOV     A,#0xf
   \   000118   12....       LCALL   ?XSTACK_DISP0_8
   \   00011B   A882         MOV     R0,DPL
   \   00011D   A983         MOV     R1,DPH
   \   00011F   7408         MOV     A,#0x8
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   E8           MOV     A,R0
   \   000125   F0           MOVX    @DPTR,A
   \   000126   A3           INC     DPTR
   \   000127   E9           MOV     A,R1
   \   000128   F0           MOVX    @DPTR,A
   1218                req.initiator = FALSE;
   \   000129   740A         MOV     A,#0xa
   \   00012B   12....       LCALL   ?XSTACK_DISP0_8
   \   00012E   E4           CLR     A
   \   00012F   F0           MOVX    @DPTR,A
   1219          
   1220                APSME_TransportKeyReq( &req );
   \   000130                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000130   7402         MOV     A,#0x2
   \   000132   12....       LCALL   ?XSTACK_DISP0_8
   \   000135   AA82         MOV     R2,DPL
   \   000137   AB83         MOV     R3,DPH
   \   000139   12....       LCALL   ??APSME_TransportKeyReq?relay
   1221              }
   1222            }
   1223          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   00013C   7427         MOV     A,#0x27
   \   00013E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000141   7F04         MOV     R7,#0x4
   \   000143   02....       LJMP    ?BANKED_LEAVE_XDATA
   1224          
   1225          /******************************************************************************
   1226           * @fn          ZDSecMgrEstablishKey
   1227           *
   1228           * @brief       Start SKKE with device joining network.
   1229           *
   1230           * @param       device - [in] ZDSecMgrDevice_t, device info
   1231           *
   1232           * @return      ZStatus_t
   1233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1234          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1235          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1236            ZStatus_t               status;
   1237            APSME_EstablishKeyReq_t req;
   1238          
   1239          
   1240            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E8           MOV     A,R0
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   E9           MOV     A,R1
   \   000022   F0           MOVX    @DPTR,A
   1241            req.method      = APSME_SKKE_METHOD;
   \   000023   7404         MOV     A,#0x4
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   1242          
   1243            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00002A   EE           MOV     A,R6
   \   00002B   2404         ADD     A,#0x4
   \   00002D   F5..         MOV     ?V0 + 0,A
   \   00002F   EF           MOV     A,R7
   \   000030   3400         ADDC    A,#0x0
   \   000032   F5..         MOV     ?V0 + 1,A
   \   000034   85..82       MOV     DPL,?V0 + 0
   \   000037   F583         MOV     DPH,A
   \   000039   C082         PUSH    DPL
   \   00003B   C083         PUSH    DPH
   \   00003D                ; Setup parameters for call to function NLME_GetShortAddr
   \   00003D   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000040   8A..         MOV     ?V0 + 2,R2
   \   000042   8B..         MOV     ?V0 + 3,R3
   \   000044   D083         POP     DPH
   \   000046   D082         POP     DPL
   \   000048   E0           MOVX    A,@DPTR
   \   000049   65..         XRL     A,?V0 + 2
   \   00004B   7004         JNZ     ??ZDSecMgrEstablishKey_0
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrEstablishKey_0:
   \   000051   7023         JNZ     ??ZDSecMgrEstablishKey_1
   1244            {
   1245              req.dstAddr   = device->nwkAddr;
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F8           MOV     R0,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F9           MOV     R1,A
   \   00005C   85..82       MOV     DPL,?XSP + 0
   \   00005F   85..83       MOV     DPH,?XSP + 1
   \   000062   E8           MOV     A,R0
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   E9           MOV     A,R1
   \   000066   F0           MOVX    @DPTR,A
   1246              //devtag.0604.todo - remove obsolete
   1247              req.apsSecure = FALSE;
   \   000067   7405         MOV     A,#0x5
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   E4           CLR     A
   \   00006D   F0           MOVX    @DPTR,A
   1248              req.nwkSecure = FALSE;
   \   00006E   7406         MOV     A,#0x6
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   E4           CLR     A
   \   000074   8025         SJMP    ??ZDSecMgrEstablishKey_2
   1249            }
   1250            else
   1251            {
   1252              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000076   85..82       MOV     DPL,?V0 + 0
   \   000079   85..83       MOV     DPH,?V0 + 1
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   F8           MOV     R0,A
   \   00007E   A3           INC     DPTR
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F9           MOV     R1,A
   \   000081   85..82       MOV     DPL,?XSP + 0
   \   000084   85..83       MOV     DPH,?XSP + 1
   \   000087   E8           MOV     A,R0
   \   000088   F0           MOVX    @DPTR,A
   \   000089   A3           INC     DPTR
   \   00008A   E9           MOV     A,R1
   \   00008B   F0           MOVX    @DPTR,A
   1253              //devtag.0604.todo - remove obsolete
   1254              req.apsSecure = TRUE;
   \   00008C   7405         MOV     A,#0x5
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   7401         MOV     A,#0x1
   \   000093   F0           MOVX    @DPTR,A
   1255              req.nwkSecure = TRUE;
   \   000094   7406         MOV     A,#0x6
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   7401         MOV     A,#0x1
   \                     ??ZDSecMgrEstablishKey_2:
   \   00009B   F0           MOVX    @DPTR,A
   1256            }
   1257          
   1258            status = APSME_EstablishKeyReq( &req );
   1259          
   1260            return status;
   \   00009C                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   00009C   85..82       MOV     DPL,?XSP + 0
   \   00009F   85..83       MOV     DPH,?XSP + 1
   \   0000A2   AA82         MOV     R2,DPL
   \   0000A4   AB83         MOV     R3,DPH
   \   0000A6   12....       LCALL   ??APSME_EstablishKeyReq?relay
   \   0000A9   7407         MOV     A,#0x7
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AE   7F04         MOV     R7,#0x4
   \   0000B0   02....       LJMP    ?BANKED_LEAVE_XDATA
   1261          }
   1262          
   1263          /******************************************************************************
   1264           * @fn          ZDSecMgrSendMasterKey
   1265           *
   1266           * @brief       Send MASTER key to device joining network.
   1267           *
   1268           * @param       device - [in] ZDSecMgrDevice_t, device info
   1269           *
   1270           * @return      ZStatus_t
   1271           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1272          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1273          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1274            ZStatus_t               status;
   1275            APSME_TransportKeyReq_t req;
   1276          
   1277          
   1278            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   F0           MOVX    @DPTR,A
   1279            req.extAddr = device->extAddr;
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F8           MOV     R0,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F9           MOV     R1,A
   \   000020   7406         MOV     A,#0x6
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E8           MOV     A,R0
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   E9           MOV     A,R1
   \   000029   F0           MOVX    @DPTR,A
   1280            req.tunnel  = NULL;
   \   00002A   740B         MOV     A,#0xb
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E4           CLR     A
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   F0           MOVX    @DPTR,A
   1281          
   1282            ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &req.key );
   \   000033                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   AC82         MOV     R4,DPL
   \   00003A   AD83         MOV     R5,DPH
   \   00003C   8E82         MOV     DPL,R6
   \   00003E   8F83         MOV     DPH,R7
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F8           MOV     R0,A
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F583         MOV     DPH,A
   \   00004E   8882         MOV     DPL,R0
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F583         MOV     DPH,A
   \   000056   8882         MOV     DPL,R0
   \   000058   E0           MOVX    A,@DPTR
   \   000059   FA           MOV     R2,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   FB           MOV     R3,A
   \   00005D   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   1283          
   1284            //check if using secure hop to to parent
   1285            if ( device->parentAddr != NLME_GetShortAddr() )
   \   000060   EE           MOV     A,R6
   \   000061   2404         ADD     A,#0x4
   \   000063   F5..         MOV     ?V0 + 0,A
   \   000065   EF           MOV     A,R7
   \   000066   3400         ADDC    A,#0x0
   \   000068   F5..         MOV     ?V0 + 1,A
   \   00006A   85..82       MOV     DPL,?V0 + 0
   \   00006D   F583         MOV     DPH,A
   \   00006F   C082         PUSH    DPL
   \   000071   C083         PUSH    DPH
   \   000073                ; Setup parameters for call to function NLME_GetShortAddr
   \   000073   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000076   8A..         MOV     ?V0 + 2,R2
   \   000078   8B..         MOV     ?V0 + 3,R3
   \   00007A   D083         POP     DPH
   \   00007C   D082         POP     DPL
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   65..         XRL     A,?V0 + 2
   \   000081   7004         JNZ     ??ZDSecMgrSendMasterKey_0
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000087   6027         JZ      ??ZDSecMgrSendMasterKey_1
   1286            {
   1287              //send to parent with security
   1288              req.dstAddr   = device->parentAddr;
   \   000089   85..82       MOV     DPL,?V0 + 0
   \   00008C   85..83       MOV     DPH,?V0 + 1
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F8           MOV     R0,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   F9           MOV     R1,A
   \   000094   85..82       MOV     DPL,?XSP + 0
   \   000097   85..83       MOV     DPH,?XSP + 1
   \   00009A   E8           MOV     A,R0
   \   00009B   F0           MOVX    @DPTR,A
   \   00009C   A3           INC     DPTR
   \   00009D   E9           MOV     A,R1
   \   00009E   F0           MOVX    @DPTR,A
   1289              req.nwkSecure = TRUE;
   \   00009F   740A         MOV     A,#0xa
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   7401         MOV     A,#0x1
   \   0000A6   F0           MOVX    @DPTR,A
   1290              req.apsSecure = TRUE;
   \   0000A7   7409         MOV     A,#0x9
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   7401         MOV     A,#0x1
   \   0000AE   8021         SJMP    ??ZDSecMgrSendMasterKey_2
   1291            }
   1292            else
   1293            {
   1294              //direct with no security
   1295              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   0000B0   8E82         MOV     DPL,R6
   \   0000B2   8F83         MOV     DPH,R7
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   F8           MOV     R0,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   F9           MOV     R1,A
   \   0000B9   85..82       MOV     DPL,?XSP + 0
   \   0000BC   85..83       MOV     DPH,?XSP + 1
   \   0000BF   E8           MOV     A,R0
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   E9           MOV     A,R1
   \   0000C3   F0           MOVX    @DPTR,A
   1296              req.nwkSecure = FALSE;
   \   0000C4   740A         MOV     A,#0xa
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   E4           CLR     A
   \   0000CA   F0           MOVX    @DPTR,A
   1297              req.apsSecure = FALSE;
   \   0000CB   7409         MOV     A,#0x9
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   E4           CLR     A
   \                     ??ZDSecMgrSendMasterKey_2:
   \   0000D1   F0           MOVX    @DPTR,A
   1298            }
   1299          
   1300            status = APSME_TransportKeyReq( &req );
   1301          
   1302            return status;
   \   0000D2                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000D2   85..82       MOV     DPL,?XSP + 0
   \   0000D5   85..83       MOV     DPH,?XSP + 1
   \   0000D8   AA82         MOV     R2,DPL
   \   0000DA   AB83         MOV     R3,DPH
   \   0000DC   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000DF   740D         MOV     A,#0xd
   \   0000E1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E4   7F04         MOV     R7,#0x4
   \   0000E6   02....       LJMP    ?BANKED_LEAVE_XDATA
   1303          }
   1304          
   1305          /******************************************************************************
   1306           * @fn          ZDSecMgrSendNwkKey
   1307           *
   1308           * @brief       Send NWK key to device joining network.
   1309           *
   1310           * @param       device - [in] ZDSecMgrDevice_t, device info
   1311           *
   1312           * @return      ZStatus_t
   1313           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1314          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1315          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1316            ZStatus_t               status;
   1317            APSME_TransportKeyReq_t req;
   1318            APSDE_FrameTunnel_t     tunnel;
   1319          
   1320            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   E8           MOV     A,R0
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   E9           MOV     A,R1
   \   000021   F0           MOVX    @DPTR,A
   1321            req.extAddr   = device->extAddr;
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F8           MOV     R0,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   7406         MOV     A,#0x6
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E8           MOV     A,R0
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   E9           MOV     A,R1
   \   000036   F0           MOVX    @DPTR,A
   1322          
   1323            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1324              req.keyType   = KEY_TYPE_NWK_HIGH;
   1325            else
   1326              req.keyType   = KEY_TYPE_NWK;
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   7401         MOV     A,#0x1
   \   00003E   F0           MOVX    @DPTR,A
   1327          
   1328            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1329                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1330            {
   1331              // set values
   1332              req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   1333              req.key       = _NIB.nwkActiveKey.key;
   1334              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1335              //key isn't used to secure the frame at the APS layer -- since the receiving
   1336              //device may not have a NWK key yet
   1337              req.apsSecure = TRUE;
   1338          
   1339              // check if using secure hop to to parent
   1340              if ( device->parentAddr == NLME_GetShortAddr() )
   1341              {
   1342                req.nwkSecure = FALSE;
   1343                req.tunnel    = NULL;
   1344              }
   1345              else
   1346              {
   1347                req.nwkSecure   = TRUE;
   1348                req.tunnel      = &tunnel;
   1349                req.tunnel->tna = device->parentAddr;
   1350                req.tunnel->dea = device->extAddr;
   1351              }
   1352            }
   1353            else
   1354            {
   1355              // default values
   1356              //devtag.0604.verify
   1357              req.nwkSecure = TRUE;
   \   00003F   740A         MOV     A,#0xa
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   7401         MOV     A,#0x1
   \   000046   F0           MOVX    @DPTR,A
   1358              req.apsSecure = FALSE;
   \   000047   7409         MOV     A,#0x9
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E4           CLR     A
   \   00004D   F0           MOVX    @DPTR,A
   1359              req.tunnel    = NULL;
   \   00004E   740B         MOV     A,#0xb
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   F0           MOVX    @DPTR,A
   1360          
   1361              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000057   EE           MOV     A,R6
   \   000058   2404         ADD     A,#0x4
   \   00005A   F5..         MOV     ?V0 + 0,A
   \   00005C   EF           MOV     A,R7
   \   00005D   3400         ADDC    A,#0x0
   \   00005F   F5..         MOV     ?V0 + 1,A
   \   000061   85..82       MOV     DPL,?V0 + 0
   \   000064   F583         MOV     DPH,A
   \   000066   C082         PUSH    DPL
   \   000068   C083         PUSH    DPH
   \   00006A                ; Setup parameters for call to function NLME_GetShortAddr
   \   00006A   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00006D   8A..         MOV     ?V0 + 2,R2
   \   00006F   8B..         MOV     ?V0 + 3,R3
   \   000071   D083         POP     DPH
   \   000073   D082         POP     DPL
   \   000075   E0           MOVX    A,@DPTR
   \   000076   65..         XRL     A,?V0 + 2
   \   000078   7004         JNZ     ??ZDSecMgrSendNwkKey_0
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrSendNwkKey_0:
   \   00007E   6016         JZ      ??ZDSecMgrSendNwkKey_1
   1362              {
   1363                req.dstAddr = device->parentAddr;
   \   000080   85..82       MOV     DPL,?V0 + 0
   \   000083   85..83       MOV     DPH,?V0 + 1
   \   000086   E0           MOVX    A,@DPTR
   \   000087   F8           MOV     R0,A
   \   000088   A3           INC     DPTR
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   F9           MOV     R1,A
   \   00008B   85..82       MOV     DPL,?XSP + 0
   \   00008E   85..83       MOV     DPH,?XSP + 1
   \   000091   E8           MOV     A,R0
   \   000092   F0           MOVX    @DPTR,A
   \   000093   A3           INC     DPTR
   \   000094   E9           MOV     A,R1
   \   000095   F0           MOVX    @DPTR,A
   1364              }
   1365          
   1366              // special cases
   1367              //devtag.0604.todo - modify to preconfig flag
   1368              if ( device->secure == FALSE )
   \                     ??ZDSecMgrSendNwkKey_1:
   \   000096   8E82         MOV     DPL,R6
   \   000098   8F83         MOV     DPH,R7
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   703E         JNZ     ??ZDSecMgrSendNwkKey_2
   1369              {
   1370                req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   \   0000A3   90....       MOV     DPTR,#_NIB + 62
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   C0E0         PUSH    A
   \   0000A9   7403         MOV     A,#0x3
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   D0E0         POP     A
   \   0000B0   F0           MOVX    @DPTR,A
   1371                req.key       = _NIB.nwkActiveKey.key;
   \   0000B1   7404         MOV     A,#0x4
   \   0000B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B6   74..         MOV     A,#(_NIB + 63) & 0xff
   \   0000B8   F0           MOVX    @DPTR,A
   \   0000B9   A3           INC     DPTR
   \   0000BA   74..         MOV     A,#((_NIB + 63) >> 8) & 0xff
   \   0000BC   F0           MOVX    @DPTR,A
   1372          
   1373                // check if using secure hop to to parent
   1374                if ( device->parentAddr == NLME_GetShortAddr() )
   \   0000BD   85..82       MOV     DPL,?V0 + 0
   \   0000C0   85..83       MOV     DPH,?V0 + 1
   \   0000C3   C082         PUSH    DPL
   \   0000C5   C083         PUSH    DPH
   \   0000C7                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000C7   12....       LCALL   ??NLME_GetShortAddr?relay
   \   0000CA   8A..         MOV     ?V0 + 0,R2
   \   0000CC   8B..         MOV     ?V0 + 1,R3
   \   0000CE   D083         POP     DPH
   \   0000D0   D082         POP     DPL
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   65..         XRL     A,?V0 + 0
   \   0000D5   7004         JNZ     ??ZDSecMgrSendNwkKey_3
   \   0000D7   A3           INC     DPTR
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000DB   7014         JNZ     ??ZDSecMgrSendNwkKey_4
   1375                {
   1376                  req.nwkSecure = FALSE;
   \   0000DD   740A         MOV     A,#0xa
   \   0000DF   800B         SJMP    ??ZDSecMgrSendNwkKey_5
   1377                }
   1378              }
   1379              else
   1380              {
   1381                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000E1   7404         MOV     A,#0x4
   \   0000E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E6   E4           CLR     A
   \   0000E7   F0           MOVX    @DPTR,A
   \   0000E8   A3           INC     DPTR
   \   0000E9   F0           MOVX    @DPTR,A
   1382                req.keySeqNum = 0;
   \   0000EA   7403         MOV     A,#0x3
   \                     ??ZDSecMgrSendNwkKey_5:
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   E4           CLR     A
   \   0000F0   F0           MOVX    @DPTR,A
   1383              }
   1384            }
   1385          
   1386            status = APSME_TransportKeyReq( &req );
   1387          
   1388            return status;
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000F1                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000F1   85..82       MOV     DPL,?XSP + 0
   \   0000F4   85..83       MOV     DPH,?XSP + 1
   \   0000F7   AA82         MOV     R2,DPL
   \   0000F9   AB83         MOV     R3,DPH
   \   0000FB   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000FE   740D         MOV     A,#0xd
   \   000100   12....       LCALL   ?DEALLOC_XSTACK8
   \   000103   7F04         MOV     R7,#0x4
   \   000105   02....       LJMP    ?BANKED_LEAVE_XDATA
   1389          }
   1390          
   1391          /******************************************************************************
   1392           * @fn          ZDSecMgrDeviceEntryRemove
   1393           *
   1394           * @brief       Remove device entry.
   1395           *
   1396           * @param       entry - [in] valid entry
   1397           *
   1398           * @return      none
   1399           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1400          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1401          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1402            // terminate device control
   1403            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1404            {
   1405              ZDSecMgrCtrlTerm( entry );
   1406            }
   1407          
   1408            // remove device from entry data
   1409            ZDSecMgrEntryFree( entry );
   \   000004                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000004   12....       LCALL   ??ZDSecMgrEntryFree?relay
   1410          
   1411            // remove EXT address
   1412            //ZDSecMgrExtAddrRelease( aiOld );
   1413          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   1414          
   1415          /******************************************************************************
   1416           * @fn          ZDSecMgrDeviceEntryAdd
   1417           *
   1418           * @brief       Add entry.
   1419           *
   1420           * @param       device - [in] ZDSecMgrDevice_t, device info
   1421           * @param       ami    - [in] Address Manager index
   1422           *
   1423           * @return      ZStatus_t
   1424           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1425          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1426          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1427            AddrMgrEntry_t entry;
   1428          
   1429            // get the ami data
   1430            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
   1431            entry.index = ami;
   \   000017   740B         MOV     A,#0xb
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   EA           MOV     A,R2
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   EB           MOV     A,R3
   \   000020   F0           MOVX    @DPTR,A
   1432          
   1433            AddrMgrEntryGet( &entry );
   \   000021                ; Setup parameters for call to function AddrMgrEntryGet
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   AA82         MOV     R2,DPL
   \   000029   AB83         MOV     R3,DPH
   \   00002B   12....       LCALL   ??AddrMgrEntryGet?relay
   1434          
   1435            // check if NWK address is same
   1436            if ( entry.nwkAddr != nwkAddr )
   \   00002E   7401         MOV     A,#0x1
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   E0           MOVX    A,@DPTR
   \   000034   6E           XRL     A,R6
   \   000035   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00003A   6017         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1437            {
   1438              // update NWK address
   1439              entry.nwkAddr = nwkAddr;
   \   00003C   7401         MOV     A,#0x1
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   EE           MOV     A,R6
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   EF           MOV     A,R7
   \   000045   F0           MOVX    @DPTR,A
   1440          
   1441              AddrMgrEntryUpdate( &entry );
   \   000046                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   AA82         MOV     R2,DPL
   \   00004E   AB83         MOV     R3,DPH
   \   000050   12....       LCALL   ??AddrMgrEntryUpdate?relay
   1442            }
   1443          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   000053   740D         MOV     A,#0xd
   \   000055   12....       LCALL   ?DEALLOC_XSTACK8
   \   000058   7F01         MOV     R7,#0x1
   \   00005A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1444          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1445          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1446          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1447            ZStatus_t        status;
   1448            ZDSecMgrEntry_t* entry;
   1449          
   1450          
   1451            // initialize as unknown until completion
   1452            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 0,#-0x38
   1453          
   1454            device->ctrl = NULL;
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
   1455          
   1456            // make sure not already registered
   1457            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \   000025                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   AC82         MOV     R4,DPL
   \   00002D   AD83         MOV     R5,DPH
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FA           MOV     R2,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   ??ZDSecMgrEntryLookup?relay
   \   00003B   E9           MOV     A,R1
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   7047         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1458            {
   1459              // verify that address index is same
   1460              if ( entry->ami != ami )
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F8           MOV     R0,A
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F583         MOV     DPH,A
   \   00004A   8882         MOV     DPL,R0
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   6E           XRL     A,R6
   \   00004E   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000053   6044         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1461              {
   1462                // remove conflicting entry
   1463                ZDSecMgrDeviceEntryRemove( entry );
   \   000055                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   000055   85..82       MOV     DPL,?XSP + 0
   \   000058   85..83       MOV     DPH,?XSP + 1
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   FA           MOV     R2,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   FB           MOV     R3,A
   \   000060   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay
   1464          
   1465                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \   000063                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000063   85..82       MOV     DPL,?XSP + 0
   \   000066   85..83       MOV     DPH,?XSP + 1
   \   000069   AC82         MOV     R4,DPL
   \   00006B   AD83         MOV     R5,DPH
   \   00006D   EE           MOV     A,R6
   \   00006E   FA           MOV     R2,A
   \   00006F   EF           MOV     A,R7
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000074   E9           MOV     A,R1
   \   000075   7022         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1466                {
   1467                  // update NWK address
   1468                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000077                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000077   85..82       MOV     DPL,?V0 + 2
   \   00007A   85..83       MOV     DPH,?V0 + 3
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   FC           MOV     R4,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   FD           MOV     R5,A
   \   000082   EE           MOV     A,R6
   \   000083   FA           MOV     R2,A
   \   000084   EF           MOV     A,R7
   \   000085   FB           MOV     R3,A
   \   000086   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   \   000089   800E         SJMP    ??ZDSecMgrDeviceEntryAdd_2
   1469                }
   1470              }
   1471            }
   1472            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   00008B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00008B   AC82         MOV     R4,DPL
   \   00008D   AD83         MOV     R5,DPH
   \   00008F   EE           MOV     A,R6
   \   000090   FA           MOV     R2,A
   \   000091   EF           MOV     A,R7
   \   000092   FB           MOV     R3,A
   \   000093   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000096   E9           MOV     A,R1
   \   000097   60DE         JZ      ??ZDSecMgrDeviceEntryAdd_3
   1473            {
   1474              // update NWK address
   1475              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1476            }
   1477          
   1478            // check if a new entry needs to be created
   1479            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   000099   85..82       MOV     DPL,?XSP + 0
   \   00009C   85..83       MOV     DPH,?XSP + 1
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   F8           MOV     R0,A
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   F9           MOV     R1,A
   \   0000A4   E8           MOV     A,R0
   \   0000A5   49           ORL     A,R1
   \   0000A6   7035         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   1480            {
   1481              // get new entry
   1482              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   0000A8                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   0000A8   85..82       MOV     DPL,?XSP + 0
   \   0000AB   85..83       MOV     DPH,?XSP + 1
   \   0000AE   AA82         MOV     R2,DPL
   \   0000B0   AB83         MOV     R3,DPH
   \   0000B2   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   0000B5   E9           MOV     A,R1
   \   0000B6   7028         JNZ     ??ZDSecMgrDeviceEntryAdd_5
   1483              {
   1484                // reset entry lkd
   1485          
   1486                // finish setting up entry
   1487                entry->ami = ami;
   \   0000B8   85..82       MOV     DPL,?XSP + 0
   \   0000BB   85..83       MOV     DPH,?XSP + 1
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   F8           MOV     R0,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F583         MOV     DPH,A
   \   0000C4   8882         MOV     DPL,R0
   \   0000C6   EE           MOV     A,R6
   \   0000C7   F0           MOVX    @DPTR,A
   \   0000C8   A3           INC     DPTR
   \   0000C9   EF           MOV     A,R7
   \   0000CA   F0           MOVX    @DPTR,A
   1488          
   1489                // update NWK address
   1490                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   0000CB                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   0000CB   85..82       MOV     DPL,?V0 + 2
   \   0000CE   85..83       MOV     DPH,?V0 + 3
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   FC           MOV     R4,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   FD           MOV     R5,A
   \   0000D6   EE           MOV     A,R6
   \   0000D7   FA           MOV     R2,A
   \   0000D8   EF           MOV     A,R7
   \   0000D9   FB           MOV     R3,A
   \   0000DA   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   1491          
   1492                // enter new device into device control
   1493                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1494                {
   1495                  status = ZDSecMgrCtrlAdd( device, entry );
   1496                }
   1497                else
   1498                {
   1499                  status = ZSuccess;
   1500                }
   1501              }
   1502            }
   1503            else
   1504            {
   1505              // reset entry lkd
   1506          
   1507              // reset entry in entry control
   1508              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1509              {
   1510                status = ZDSecMgrCtrlReset( device, entry );
   1511              }
   1512              else
   1513              {
   1514                status = ZSuccess;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   0000DD   75..00       MOV     ?V0 + 0,#0x0
   1515              }
   1516            }
   1517          
   1518            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_5:
   \   0000E0   A9..         MOV     R1,?V0 + 0
   \   0000E2   7402         MOV     A,#0x2
   \   0000E4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E7   7F04         MOV     R7,#0x4
   \   0000E9   02....       LJMP    ?BANKED_LEAVE_XDATA
   1519          }
   1520          
   1521          /******************************************************************************
   1522           * @fn          ZDSecMgrDeviceCtrlHandler
   1523           *
   1524           * @brief       Device control handler.
   1525           *
   1526           * @param       device - [in] ZDSecMgrDevice_t, device info
   1527           *
   1528           * @return      none
   1529           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1530          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1531          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1532            uint8 state;
   1533            uint8 cntr;
   1534          
   1535          
   1536            state = device->ctrl->state;
   \   000005   EA           MOV     A,R2
   \   000006   2408         ADD     A,#0x8
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   FF           MOV     R7,A
   \   00000D   8E82         MOV     DPL,R6
   \   00000F   8F83         MOV     DPH,R7
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F583         MOV     DPH,A
   \   000017   8882         MOV     DPL,R0
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F5..         MOV     ?V0 + 0,A
   1537            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1538          
   1539            switch ( state )
   \   000021   24FE         ADD     A,#-0x2
   \   000023   600C         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   \   000025   14           DEC     A
   \   000026   6014         JZ      ??ZDSecMgrDeviceCtrlHandler_1
   \   000028   14           DEC     A
   \   000029   6025         JZ      ??ZDSecMgrDeviceCtrlHandler_2
   \   00002B   24FD         ADD     A,#-0x3
   \   00002D   6018         JZ      ??ZDSecMgrDeviceCtrlHandler_3
   \   00002F   801C         SJMP    ??ZDSecMgrDeviceCtrlHandler_4
   1540            {
   1541              case ZDSECMGR_CTRL_TK_MASTER:
   1542                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000031                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   000031   12....       LCALL   ??ZDSecMgrSendMasterKey?relay
   \   000034   E9           MOV     A,R1
   \   000035   7019         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1543                {
   1544                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000037   75..03       MOV     ?V0 + 0,#0x3
   1545                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   00003A   8014         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1546                }
   1547                break;
   1548          
   1549              case ZDSECMGR_CTRL_SKKE_INIT:
   1550                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   00003C                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   00003C   12....       LCALL   ??ZDSecMgrEstablishKey?relay
   \   00003F   E9           MOV     A,R1
   \   000040   700E         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1551                {
   1552                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000042   75..04       MOV     ?V0 + 0,#0x4
   \   000045   8009         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1553                }
   1554                break;
   1555          
   1556              case ZDSECMGR_CTRL_SKKE_WAIT:
   1557                // continue to wait for SKA control timeout
   1558                break;
   1559          
   1560              case ZDSECMGR_CTRL_TK_NWK:
   1561                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   000047                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000047   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   00004A   E9           MOV     A,R1
   \   00004B   7003         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1562                {
   1563                  state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   00004D   75..00       MOV     ?V0 + 0,#0x0
   1564                }
   1565                break;
   1566          
   1567              default:
   1568                state = ZDSECMGR_CTRL_NONE;
   1569                break;
   1570            }
   1571          
   1572            if ( state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   000050   E5..         MOV     A,?V0 + 0
   \   000052   8E82         MOV     DPL,R6
   \   000054   8F83         MOV     DPH,R7
   \   000056   6036         JZ      ??ZDSecMgrDeviceCtrlHandler_5
   1573            {
   1574              device->ctrl->state = state;
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F8           MOV     R0,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F583         MOV     DPH,A
   \   00005E   8882         MOV     DPL,R0
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   E5..         MOV     A,?V0 + 0
   \   000067   F0           MOVX    @DPTR,A
   1575              device->ctrl->cntr  = cntr;
   \   000068   8E82         MOV     DPL,R6
   \   00006A   8F83         MOV     DPH,R7
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F8           MOV     R0,A
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F583         MOV     DPH,A
   \   000072   8882         MOV     DPL,R0
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   7401         MOV     A,#0x1
   \   00007C   F0           MOVX    @DPTR,A
   1576          
   1577              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   00007D                ; Setup parameters for call to function osal_start_timerEx
   \   00007D   7C64         MOV     R4,#0x64
   \   00007F   7D00         MOV     R5,#0x0
   \   000081   7A00         MOV     R2,#0x0
   \   000083   FB           MOV     R3,A
   \   000084   90....       MOV     DPTR,#ZDAppTaskID
   \   000087   E0           MOVX    A,@DPTR
   \   000088   F9           MOV     R1,A
   \   000089   12....       LCALL   ??osal_start_timerEx?relay
   \   00008C   8008         SJMP    ??ZDSecMgrDeviceCtrlHandler_6
   1578            }
   1579            else
   1580            {
   1581              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   00008E                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   FA           MOV     R2,A
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   FB           MOV     R3,A
   \   000093   12....       LCALL   ??ZDSecMgrCtrlRelease?relay
   1582            }
   1583          }
   \                     ??ZDSecMgrDeviceCtrlHandler_6:
   \   000096   7F01         MOV     R7,#0x1
   \   000098   02....       LJMP    ?BANKED_LEAVE_XDATA
   1584          
   1585          /******************************************************************************
   1586           * @fn          ZDSecMgrDeviceCtrlSetup
   1587           *
   1588           * @brief       Setup device control.
   1589           *
   1590           * @param       device - [in] ZDSecMgrDevice_t, device info
   1591           *
   1592           * @return      ZStatus_t
   1593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1594          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1595          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1596            if ( device->ctrl != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   2408         ADD     A,#0x8
   \   000007   F8           MOV     R0,A
   \   000008   EB           MOV     A,R3
   \   000009   3400         ADDC    A,#0x0
   \   00000B   F9           MOV     R1,A
   \   00000C   8882         MOV     DPL,R0
   \   00000E   8983         MOV     DPH,R1
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FC           MOV     R4,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FD           MOV     R5,A
   \   000015   EC           MOV     A,R4
   \   000016   4D           ORL     A,R5
   \   000017   6035         JZ      ??ZDSecMgrDeviceCtrlSetup_0
   1597            {
   1598              if ( device->secure == FALSE )
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   7011         JNZ     ??ZDSecMgrDeviceCtrlSetup_1
   1599              {
   1600                // send the master key data to the joining device
   1601                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F583         MOV     DPH,A
   \   000030   8882         MOV     DPL,R0
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   7402         MOV     A,#0x2
   \   000039   800F         SJMP    ??ZDSecMgrDeviceCtrlSetup_2
   1602              }
   1603              else
   1604              {
   1605                // start SKKE
   1606                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F583         MOV     DPH,A
   \   000041   8882         MOV     DPL,R0
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   7403         MOV     A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   00004A   F0           MOVX    @DPTR,A
   1607              }
   1608          
   1609              ZDSecMgrDeviceCtrlHandler( device );
   \   00004B                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   00004B   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   1610            }
   1611          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   00004E   D083         POP     DPH
   \   000050   D082         POP     DPL
   \   000052   02....       LJMP    ?BRET
   1612          
   1613          /******************************************************************************
   1614           * @fn          ZDSecMgrDeviceCtrlUpdate
   1615           *
   1616           * @brief       Update control data.
   1617           *
   1618           * @param       extAddr - [in] EXT address
   1619           * @param       state   - [in] new control state
   1620           *
   1621           * @return      none
   1622           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1623          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1624          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1625            ZDSecMgrEntry_t* entry;
   1626            ZDSecMgrCtrl_t*  ctrl;
   1627          
   1628          
   1629            // lookup device entry data
   1630            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV     A,#0x2
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   AC82         MOV     R4,DPL
   \   000013   AD83         MOV     R5,DPH
   \   000015   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   1631          
   1632            if ( entry != NULL )
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   49           ORL     A,R1
   \   000024   6066         JZ      ??ZDSecMgrDeviceCtrlUpdate_0
   1633            {
   1634              // lookup device control data
   1635              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000026                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   AC82         MOV     R4,DPL
   \   00002E   AD83         MOV     R5,DPH
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FA           MOV     R2,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1636          
   1637              // make sure control data is valid
   1638              if ( ctrl != NULL )
   \   00003D   85..82       MOV     DPL,?XSP + 0
   \   000040   85..83       MOV     DPH,?XSP + 1
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F8           MOV     R0,A
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   E8           MOV     A,R0
   \   000049   49           ORL     A,R1
   \   00004A   6040         JZ      ??ZDSecMgrDeviceCtrlUpdate_0
   1639              {
   1640                // possible state transitions
   1641                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   E0           MOVX    A,@DPTR
   \   000053   2405         ADD     A,#0x5
   \   000055   F8           MOV     R0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   3400         ADDC    A,#0x0
   \   00005A   F9           MOV     R1,A
   \   00005B   8882         MOV     DPL,R0
   \   00005D   8983         MOV     DPH,R1
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   6404         XRL     A,#0x4
   \   000062   7028         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1642                {
   1643                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000064   7405         MOV     A,#0x5
   \   000066   6E           XRL     A,R6
   \   000067   7004         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1644                  {
   1645                    // send the network key
   1646                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   000069   7407         MOV     A,#0x7
   \   00006B   8007         SJMP    ??ZDSecMgrDeviceCtrlUpdate_2
   1647                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1648                  }
   1649                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   00006D   7406         MOV     A,#0x6
   \   00006F   6E           XRL     A,R6
   \   000070   701A         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1650                  {
   1651                    // force default timeout in order to cleanup control logic
   1652                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   000072   7406         MOV     A,#0x6
   \                     ??ZDSecMgrDeviceCtrlUpdate_2:
   \   000074   F0           MOVX    @DPTR,A
   1653                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   000075   85..82       MOV     DPL,?XSP + 0
   \   000078   85..83       MOV     DPH,?XSP + 1
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F8           MOV     R0,A
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F583         MOV     DPH,A
   \   000081   8882         MOV     DPL,R0
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   7401         MOV     A,#0x1
   \   00008B   F0           MOVX    @DPTR,A
   1654                  }
   1655                }
   1656                // timer should be active
   1657              }
   1658            }
   1659          }
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   00008C   7404         MOV     A,#0x4
   \   00008E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000091   7F01         MOV     R7,#0x1
   \   000093   02....       LJMP    ?BANKED_LEAVE_XDATA
   1660          
   1661          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1662          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1663          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1664            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1665            {
   1666              if ( initiator == TRUE )
   1667              {
   1668                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1669              }
   1670            }
   1671          }
   \   000000   02....       LJMP    ?BRET
   1672          
   1673          /******************************************************************************
   1674           * @fn          ZDSecMgrDeviceRemove
   1675           *
   1676           * @brief       Remove device from network.
   1677           *
   1678           * @param       device - [in] ZDSecMgrDevice_t, device info
   1679           *
   1680           * @return      none
   1681           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1682          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1683          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1684            APSME_RemoveDeviceReq_t remDevReq;
   1685            NLME_LeaveReq_t         leaveReq;
   1686            associated_devices_t*   assoc;
   1687          
   1688          
   1689            // check if parent, remove the device
   1690            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000A   EA           MOV     A,R2
   \   00000B   2402         ADD     A,#0x2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   3400         ADDC    A,#0x0
   \   000011   FF           MOV     R7,A
   \   000012   EA           MOV     A,R2
   \   000013   2404         ADD     A,#0x4
   \   000015   F5..         MOV     ?V0 + 0,A
   \   000017   EB           MOV     A,R3
   \   000018   3400         ADDC    A,#0x0
   \   00001A   F5..         MOV     ?V0 + 1,A
   \   00001C   85..82       MOV     DPL,?V0 + 0
   \   00001F   F583         MOV     DPH,A
   \   000021   C082         PUSH    DPL
   \   000023   C083         PUSH    DPH
   \   000025                ; Setup parameters for call to function NLME_GetShortAddr
   \   000025   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000028   8A..         MOV     ?V0 + 2,R2
   \   00002A   8B..         MOV     ?V0 + 3,R3
   \   00002C   D083         POP     DPH
   \   00002E   D082         POP     DPL
   \   000030   E0           MOVX    A,@DPTR
   \   000031   65..         XRL     A,?V0 + 2
   \   000033   7004         JNZ     ??ZDSecMgrDeviceRemove_0
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrDeviceRemove_0:
   \   000039   7074         JNZ     ??ZDSecMgrDeviceRemove_1
   1691            {
   1692              // this is the parent of the device
   1693              leaveReq.extAddr        = device->extAddr;
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F8           MOV     R0,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F9           MOV     R1,A
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   E8           MOV     A,R0
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   E9           MOV     A,R1
   \   00004E   F0           MOVX    @DPTR,A
   1694              leaveReq.removeChildren = FALSE;
   \   00004F   7402         MOV     A,#0x2
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E4           CLR     A
   \   000055   F0           MOVX    @DPTR,A
   1695              leaveReq.rejoin         = FALSE;
   \   000056   7403         MOV     A,#0x3
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
   1696          
   1697              // find child association
   1698              assoc = AssocGetWithExt( device->extAddr );
   \   00005D                ; Setup parameters for call to function AssocGetWithExt
   \   00005D   8E82         MOV     DPL,R6
   \   00005F   8F83         MOV     DPH,R7
   \   000061   E0           MOVX    A,@DPTR
   \   000062   FA           MOV     R2,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   FB           MOV     R3,A
   \   000066   12....       LCALL   ??AssocGetWithExt?relay
   \   000069   8A..         MOV     ?V0 + 0,R2
   \   00006B   8B..         MOV     ?V0 + 1,R3
   \   00006D   A8..         MOV     R0,?V0 + 0
   \   00006F   A9..         MOV     R1,?V0 + 1
   1699          
   1700              if ( ( assoc != NULL                            ) &&
   1701                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1702                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000071   E8           MOV     A,R0
   \   000072   49           ORL     A,R1
   \   000073   606E         JZ      ??ZDSecMgrDeviceRemove_2
   \   000075   8882         MOV     DPL,R0
   \   000077   8983         MOV     DPH,R1
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   14           DEC     A
   \   00007F   C3           CLR     C
   \   000080   9404         SUBB    A,#0x4
   \   000082   505F         JNC     ??ZDSecMgrDeviceRemove_2
   1703              {
   1704                // check if associated device is authenticated
   1705                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000084   8882         MOV     DPL,R0
   \   000086   8983         MOV     DPH,R1
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   A2E3         MOV     C,0xE0 /* A   */.3
   \   000090   7404         MOV     A,#0x4
   \   000092   5006         JNC     ??ZDSecMgrDeviceRemove_3
   1706                {
   1707                  leaveReq.silent = FALSE;
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   E4           CLR     A
   \   000098   8005         SJMP    ??ZDSecMgrDeviceRemove_4
   1708                }
   1709                else
   1710                {
   1711                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceRemove_4:
   \   00009F   F0           MOVX    @DPTR,A
   1712                }
   1713          
   1714                NLME_LeaveReq( &leaveReq );
   \   0000A0                ; Setup parameters for call to function NLME_LeaveReq
   \   0000A0   85..82       MOV     DPL,?XSP + 0
   \   0000A3   85..83       MOV     DPH,?XSP + 1
   \   0000A6   AA82         MOV     R2,DPL
   \   0000A8   AB83         MOV     R3,DPH
   \   0000AA   12....       LCALL   ??NLME_LeaveReq?relay
   \   0000AD   8034         SJMP    ??ZDSecMgrDeviceRemove_2
   1715              }
   1716            }
   1717            else
   1718            {
   1719              // this is not the parent of the device
   1720              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   0000AF   85..82       MOV     DPL,?V0 + 0
   \   0000B2   85..83       MOV     DPH,?V0 + 1
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   F8           MOV     R0,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F9           MOV     R1,A
   \   0000BA   7405         MOV     A,#0x5
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   E8           MOV     A,R0
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   E9           MOV     A,R1
   \   0000C3   F0           MOVX    @DPTR,A
   1721              remDevReq.childExtAddr = device->extAddr;
   \   0000C4   8E82         MOV     DPL,R6
   \   0000C6   8F83         MOV     DPH,R7
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F8           MOV     R0,A
   \   0000CA   A3           INC     DPTR
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   F9           MOV     R1,A
   \   0000CD   7407         MOV     A,#0x7
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   E8           MOV     A,R0
   \   0000D3   F0           MOVX    @DPTR,A
   \   0000D4   A3           INC     DPTR
   \   0000D5   E9           MOV     A,R1
   \   0000D6   F0           MOVX    @DPTR,A
   1722          
   1723              APSME_RemoveDeviceReq( &remDevReq );
   \   0000D7                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   0000D7   7405         MOV     A,#0x5
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   AA82         MOV     R2,DPL
   \   0000DE   AB83         MOV     R3,DPH
   \   0000E0   12....       LCALL   ??APSME_RemoveDeviceReq?relay
   1724            }
   1725          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   0000E3   7409         MOV     A,#0x9
   \   0000E5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E8   7F04         MOV     R7,#0x4
   \   0000EA   02....       LJMP    ?BANKED_LEAVE_XDATA
   1726          
   1727          /******************************************************************************
   1728           * @fn          ZDSecMgrDeviceValidateSKKE
   1729           *
   1730           * @brief       Decide whether device is allowed for SKKE.
   1731           *
   1732           * @param       device - [in] ZDSecMgrDevice_t, device info
   1733           *
   1734           * @return      ZStatus_t
   1735           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1736          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1737          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1738            ZStatus_t status;
   1739            uint16    ami;
   1740            uint8*    key;
   1741          
   1742          
   1743            // get EXT address
   1744            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FA           MOV     R2,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000026   E9           MOV     A,R1
   1745          
   1746            if ( status == ZSuccess )
   \   000027   702C         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1747            {
   1748              // get MASTER key
   1749              status = ZDSecMgrMasterKeyLookup( ami, &key );
   \   000029                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000029   7402         MOV     A,#0x2
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   AC82         MOV     R4,DPL
   \   000030   AD83         MOV     R5,DPH
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000040   E9           MOV     A,R1
   1750          
   1751              if ( status == ZSuccess )
   \   000041   7012         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1752              {
   1753              //  // check if initiator is Trust Center
   1754              //  if ( device->nwkAddr == APSME_TRUSTCENTER_NWKADDR )
   1755              //  {
   1756              //    // verify NWK key not sent
   1757              //    // devtag.todo
   1758              //    // temporary - add device to internal data
   1759              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1760              //  }
   1761              //  else
   1762              //  {
   1763              //    // initiator not Trust Center - End to End SKKE - set policy
   1764              //    // for accepting an SKKE initiation
   1765              //    // temporary - add device to internal data
   1766              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1767              //  }
   1768                  status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000043                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   FC           MOV     R4,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   FD           MOV     R5,A
   \   00004E   EE           MOV     A,R6
   \   00004F   FA           MOV     R2,A
   \   000050   EF           MOV     A,R7
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   1769              }
   1770            }
   1771          
   1772            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   7F01         MOV     R7,#0x1
   \   00005C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1773          }
   1774          
   1775          /******************************************************************************
   1776           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1777           *
   1778           * @brief       Decide whether device is allowed.
   1779           *
   1780           * @param       device - [in] ZDSecMgrDevice_t, device info
   1781           *
   1782           * @return      ZStatus_t
   1783           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1784          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1785          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1786          
   1787            ZStatus_t status;
   1788            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1789          
   1790            (void)device;  // Intentionally unreferenced parameter
   1791            
   1792            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1793            // the trust center to reject any newly joining devices by sending
   1794            // Remove-device to the parents.
   1795            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1796            {
   1797              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1798            }
   1799          
   1800          
   1801          
   1802          #if 0  // Taken out because the following functionality is only used for test
   1803                 // purpose. A more efficient (above) way is used. It can be put
   1804                 // back in if customers request for a white/black list feature.
   1805                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1806          
   1807            // The following code processes the device black list (stored device list)
   1808            // If the joining device is not part of the forbidden device list
   1809            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1810            // will send Remove-device and ban the device from joining.
   1811          
   1812            uint8     index;
   1813            uint8*    restricted;
   1814          
   1815            // Look through the stored device list - used for restricted devices
   1816            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1817            {
   1818              restricted = ZDSecMgrStoredDeviceList[index];
   1819          
   1820              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1821              {
   1822                // return as unknown device in regards to validation
   1823                status = ZNwkUnknownDevice;
   1824          
   1825                // break from loop
   1826                index = ZDSECMGR_STORED_DEVICES;
   1827              }
   1828            }
   1829          
   1830          #endif
   1831          
   1832            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
   1833          }
   1834          
   1835          /******************************************************************************
   1836           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1837           *
   1838           * @brief       Decide whether device is allowed.
   1839           *
   1840           * @param       device - [in] ZDSecMgrDevice_t, device info
   1841           *
   1842           * @return      ZStatus_t
   1843           */
   1844          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1845          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1846          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1847            ZStatus_t status;
   1848            uint16    ami;
   1849            uint8*    key;
   1850          
   1851          
   1852          //  // check for pre configured setting
   1853          //  if ( device->secure == TRUE )
   1854          //  {
   1855          //    // get EXT address and MASTER key
   1856          //    status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1857          //
   1858          //    if ( status == ZSuccess )
   1859          //    {
   1860          //      status = ZDSecMgrMasterKeyLookup( ami, &key );
   1861          //    }
   1862          //  }
   1863          //  else
   1864          //  {
   1865              // implement EXT address and MASTER key policy here -- the total number of
   1866              // Security Manager entries should never exceed the number of EXT addresses
   1867              // and MASTER keys available
   1868          
   1869              // set status based on policy
   1870              //status = ZNwkUnknownDevice;
   1871          
   1872              // set status based on policy
   1873              status = ZSuccess; // ZNwkUnknownDevice;
   1874          
   1875              // get key based on policy
   1876              key = ZDSecMgrTCMasterKey;
   1877          
   1878              // if policy, store new EXT address
   1879              status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00000E   EE           MOV     A,R6
   \   00000F   2402         ADD     A,#0x2
   \   000011   F5..         MOV     ?V0 + 0,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   8582..       MOV     ?V0 + 2,DPL
   \   000021   8583..       MOV     ?V0 + 3,DPH
   \   000024   78..         MOV     R0,#?V0 + 2
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   85..82       MOV     DPL,?V0 + 0
   \   00002C   85..83       MOV     DPH,?V0 + 1
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FC           MOV     R4,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FD           MOV     R5,A
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000040   7402         MOV     A,#0x2
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
   \   000045   E9           MOV     A,R1
   \   000046   F5..         MOV     ?V0 + 2,A
   1880          
   1881              // set the key
   1882              ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   000048                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   000048   7C..         MOV     R4,#ZDSecMgrTCMasterKey & 0xff
   \   00004A   7D..         MOV     R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00004C   85..82       MOV     DPL,?V0 + 0
   \   00004F   85..83       MOV     DPH,?V0 + 1
   \   000052   E0           MOVX    A,@DPTR
   \   000053   FA           MOV     R2,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   FB           MOV     R3,A
   \   000057   12....       LCALL   ??ZDSecMgrMasterKeyLoad?relay
   1883          //  }
   1884          
   1885            // if EXT address and MASTER key available -- add device
   1886            if ( status == ZSuccess )
   \   00005A   E5..         MOV     A,?V0 + 2
   \   00005C   7015         JNZ     ??ZDSecMgrDeviceValidateCM_0
   1887            {
   1888              // add device to internal data - with control
   1889              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00005E                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00005E   85..82       MOV     DPL,?XSP + 0
   \   000061   85..83       MOV     DPH,?XSP + 1
   \   000064   E0           MOVX    A,@DPTR
   \   000065   FC           MOV     R4,A
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FD           MOV     R5,A
   \   000069   EE           MOV     A,R6
   \   00006A   FA           MOV     R2,A
   \   00006B   EF           MOV     A,R7
   \   00006C   FB           MOV     R3,A
   \   00006D   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   000070   E9           MOV     A,R1
   \   000071   F5..         MOV     ?V0 + 2,A
   1890            }
   1891          
   1892            return status;
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   000073   A9..         MOV     R1,?V0 + 2
   \   000075   7402         MOV     A,#0x2
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007A   7F04         MOV     R7,#0x4
   \   00007C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1893          }
   1894          //devtag.pro.security
   1895          #if 0
   1896          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   1897          {
   1898            ZStatus_t status;
   1899            uint16    ami;
   1900            uint8*    key;
   1901          
   1902          
   1903            // check for pre configured setting
   1904            if ( device->secure == TRUE )
   1905            {
   1906              // get EXT address and MASTER key
   1907              status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1908          
   1909              if ( status == ZSuccess )
   1910              {
   1911                status = ZDSecMgrMasterKeyLookup( ami, &key );
   1912              }
   1913            }
   1914            else
   1915            {
   1916              // implement EXT address and MASTER key policy here -- the total number of
   1917              // Security Manager entries should never exceed the number of EXT addresses
   1918              // and MASTER keys available
   1919          
   1920              // set status based on policy
   1921              status = ZSuccess; // ZNwkUnknownDevice;
   1922          
   1923              // get the address index
   1924              if ( ZDSecMgrExtAddrLookup( device->extAddr, &ami ) != ZSuccess )
   1925              {
   1926                // if policy, store new EXT address
   1927                status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   1928              }
   1929          
   1930              // get the address index
   1931              if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   1932              {
   1933                // if policy, store new key -- NULL will zero key
   1934                status = ZDSecMgrMasterKeyStore( ami, NULL );
   1935              }
   1936            }
   1937          
   1938            // if EXT address and MASTER key available -- add device
   1939            if ( status == ZSuccess )
   1940            {
   1941              // add device to internal data - with control
   1942              status = ZDSecMgrDeviceEntryAdd( device, ami );
   1943            }
   1944          
   1945            return status;
   1946          }
   1947          #endif
   1948          
   1949          /******************************************************************************
   1950           * @fn          ZDSecMgrDeviceValidate
   1951           *
   1952           * @brief       Decide whether device is allowed.
   1953           *
   1954           * @param       device - [in] ZDSecMgrDevice_t, device info
   1955           *
   1956           * @return      ZStatus_t
   1957           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1958          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1959          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1960            ZStatus_t status;
   1961          
   1962          
   1963            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   701F         JNZ     ??ZDSecMgrDeviceValidate_0
   1964            {
   1965              // device may be joining with a secure flag but it is ultimately the Trust
   1966              // Center that decides -- check if expected pre configured device --
   1967              // override settings
   1968              if ( zgPreConfigKeys == TRUE )
   \   00000C   EA           MOV     A,R2
   \   00000D   2406         ADD     A,#0x6
   \   00000F   F8           MOV     R0,A
   \   000010   EB           MOV     A,R3
   \   000011   3400         ADDC    A,#0x0
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#zgPreConfigKeys
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   7004         JNZ     ??ZDSecMgrDeviceValidate_1
   1969              {
   1970                device->secure = TRUE;
   \   000020   7401         MOV     A,#0x1
   \   000022   8001         SJMP    ??ZDSecMgrDeviceValidate_2
   1971              }
   1972              else
   1973              {
   1974                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000024   E4           CLR     A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000025   F0           MOVX    @DPTR,A
   1975              }
   1976          
   1977              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1978              {
   1979                status = ZDSecMgrDeviceValidateCM( device );
   1980              }
   1981              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1982              {
   1983                status = ZDSecMgrDeviceValidateRM( device );
   \   000026                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000026   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay
   \   000029   8002         SJMP    ??ZDSecMgrDeviceValidate_3
   1984              }
   1985            }
   1986            else
   1987            {
   1988              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002B   79C8         MOV     R1,#-0x38
   1989            }
   1990          
   1991            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002D   D083         POP     DPH
   \   00002F   D082         POP     DPL
   \   000031   02....       LJMP    ?BRET
   1992          }
   1993          
   1994          /******************************************************************************
   1995           * @fn          ZDSecMgrDeviceJoin
   1996           *
   1997           * @brief       Try to join this device.
   1998           *
   1999           * @param       device - [in] ZDSecMgrDevice_t, device info
   2000           *
   2001           * @return      ZStatus_t
   2002           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2003          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2004          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2005            ZStatus_t status;
   2006          
   2007            // attempt to validate device
   2008            status = ZDSecMgrDeviceValidate( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   000009   12....       LCALL   ??ZDSecMgrDeviceValidate?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   2009          
   2010            if ( status == ZSuccess )
   \   00000F   700C         JNZ     ??ZDSecMgrDeviceJoin_0
   2011            {
   2012              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2013              {
   2014                ZDSecMgrDeviceCtrlSetup( device );
   2015              }
   2016              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2017              {
   2018                //send the nwk key data to the joining device
   2019                status = ZDSecMgrSendNwkKey( device );
   \   000011                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000011   EE           MOV     A,R6
   \   000012   FA           MOV     R2,A
   \   000013   EF           MOV     A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000018   E9           MOV     A,R1
   \   000019   F5..         MOV     ?V0 + 0,A
   \   00001B   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2020              }
   2021            }
   2022            else
   2023            {
   2024              // not allowed, remove the device
   2025              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   00001D                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2026            }
   2027          
   2028            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000024   A9..         MOV     R1,?V0 + 0
   \   000026   7F01         MOV     R7,#0x1
   \   000028   02....       LJMP    ?BANKED_LEAVE_XDATA
   2029          }
   2030          
   2031          /******************************************************************************
   2032           * @fn          ZDSecMgrDeviceJoinDirect
   2033           *
   2034           * @brief       Try to join this device as a direct child.
   2035           *
   2036           * @param       device - [in] ZDSecMgrDevice_t, device info
   2037           *
   2038           * @return      ZStatus_t
   2039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2040          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2041          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2042            ZStatus_t status;
   2043          
   2044            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   2045          
   2046            if ( status == ZSuccess )
   \   00000F   700F         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2047            {
   2048              // set association status to authenticated
   2049              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FA           MOV     R2,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   ??AssocGetWithShort?relay
   \   00001D   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2050            }
   2051          
   2052            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   000020   A9..         MOV     R1,?V0 + 0
   \   000022   7F01         MOV     R7,#0x1
   \   000024   02....       LJMP    ?BANKED_LEAVE_XDATA
   2053          }
   2054          
   2055          /******************************************************************************
   2056           * @fn          ZDSecMgrDeviceJoinFwd
   2057           *
   2058           * @brief       Forward join to Trust Center.
   2059           *
   2060           * @param       device - [in] ZDSecMgrDevice_t, device info
   2061           *
   2062           * @return      ZStatus_t
   2063           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2064          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2065          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2066            ZStatus_t               status;
   2067            APSME_UpdateDeviceReq_t req;
   2068          
   2069          
   2070            // forward any joining device to the Trust Center -- the Trust Center will
   2071            // decide if the device is allowed to join
   2072            status = ZSuccess;
   2073          
   2074            // forward authorization to the Trust Center
   2075            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
   2076            req.devAddr    = device->nwkAddr;
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   E8           MOV     A,R0
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E9           MOV     A,R1
   \   000025   F0           MOVX    @DPTR,A
   2077            req.devExtAddr = device->extAddr;
   \   000026   8A82         MOV     DPL,R2
   \   000028   8B83         MOV     DPH,R3
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F8           MOV     R0,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F9           MOV     R1,A
   \   000031   7404         MOV     A,#0x4
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E8           MOV     A,R0
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   E9           MOV     A,R1
   \   00003A   F0           MOVX    @DPTR,A
   2078          
   2079            // set security status, option for router to reject if policy set
   2080            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \   00003B   EA           MOV     A,R2
   \   00003C   2407         ADD     A,#0x7
   \   00003E   F582         MOV     DPL,A
   \   000040   EB           MOV     A,R3
   \   000041   3400         ADDC    A,#0x0
   \   000043   F583         MOV     DPH,A
   \   000045   E0           MOVX    A,@DPTR
   \   000046   A2E7         MOV     C,0xE0 /* A   */.7
   \   000048   E0           MOVX    A,@DPTR
   \   000049   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2081            {
   2082              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   00004B   A2E6         MOV     C,0xE0 /* A   */.6
   \   00004D   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2083              {
   2084                if ( device->secure == TRUE )
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   6401         XRL     A,#0x1
   \   00005C   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2085                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   00005E   7406         MOV     A,#0x6
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   7404         MOV     A,#0x4
   \   000065   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2086                else
   2087                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   000067   7406         MOV     A,#0x6
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   7407         MOV     A,#0x7
   \   00006E   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2088              }
   2089              else
   2090                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000070   7406         MOV     A,#0x6
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   7405         MOV     A,#0x5
   \   000077   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2091            }
   2092            else
   2093            {
   2094              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000079   A2E6         MOV     C,0xE0 /* A   */.6
   \   00007B   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2095              {
   2096                if ( device->secure == TRUE )
   \   00007D   8A82         MOV     DPL,R2
   \   00007F   8B83         MOV     DPH,R3
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   6401         XRL     A,#0x1
   \   00008A   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2097                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   00008C   7406         MOV     A,#0x6
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   E4           CLR     A
   \   000092   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2098                else
   2099                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000094   7406         MOV     A,#0x6
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   7403         MOV     A,#0x3
   \   00009B   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2100              }
   2101              else
   2102                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   00009D   7406         MOV     A,#0x6
   \   00009F   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A2   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   0000A4   F0           MOVX    @DPTR,A
   2103            }
   2104          
   2105            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2106              req.apsSecure = TRUE;
   2107            else
   2108              req.apsSecure = FALSE;
   \   0000A5   7407         MOV     A,#0x7
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   E4           CLR     A
   \   0000AB   F0           MOVX    @DPTR,A
   2109          
   2110            // send and APSME_UPDATE_DEVICE request to the trust center
   2111            status = APSME_UpdateDeviceReq( &req );
   2112          
   2113            return status;
   \   0000AC                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   0000AC   85..82       MOV     DPL,?XSP + 0
   \   0000AF   85..83       MOV     DPH,?XSP + 1
   \   0000B2   AA82         MOV     R2,DPL
   \   0000B4   AB83         MOV     R3,DPH
   \   0000B6   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   \   0000B9   7408         MOV     A,#0x8
   \   0000BB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BE   D083         POP     DPH
   \   0000C0   D082         POP     DPL
   \   0000C2   02....       LJMP    ?BRET
   2114          }
   2115          
   2116          /******************************************************************************
   2117           * @fn          ZDSecMgrDeviceNew
   2118           *
   2119           * @brief       Process a new device.
   2120           *
   2121           * @param       device - [in] ZDSecMgrDevice_t, device info
   2122           *
   2123           * @return      ZStatus_t
   2124           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2125          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2126          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2127            ZStatus_t status;
   2128          
   2129            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2130            {
   2131              // try to join this device
   2132              status = ZDSecMgrDeviceJoinDirect( joiner );
   2133            }
   2134            else
   2135            {
   2136              status = ZDSecMgrDeviceJoinFwd( joiner );
   2137            }
   2138          
   2139            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000004   12....       LCALL   ??ZDSecMgrDeviceJoinFwd?relay
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   2140          }
   2141          
   2142          /******************************************************************************
   2143           * @fn          ZDSecMgrAssocDeviceAuth
   2144           *
   2145           * @brief       Set associated device status to authenticated
   2146           *
   2147           * @param       assoc - [in, out] associated_devices_t
   2148           *
   2149           * @return      none
   2150           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2151          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2152          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2153            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   2154            {
   2155              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   2156            }
   2157          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   02....       LJMP    ?BRET
   2158          
   2159          /******************************************************************************
   2160           * @fn          ZDSecMgrAuthInitiate
   2161           *
   2162           * @brief       Initiate entity authentication
   2163           *
   2164           * @param       responder - [in] responder EXT address
   2165           *
   2166           * @return      none
   2167           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2168          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2169          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2170            APSME_AuthenticateReq_t req;
   2171          
   2172          
   2173            // make sure NWK address is available
   2174            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   6027         JZ      ??ZDSecMgrAuthInitiate_0
   2175            {
   2176              // set request fields
   2177              req.extAddr   = responder;
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   F0           MOVX    @DPTR,A
   2178              req.action    = APSME_EA_INITIATE;
   \   000028   7406         MOV     A,#0x6
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E4           CLR     A
   \   00002E   F0           MOVX    @DPTR,A
   2179              req.challenge = NULL;
   \   00002F   7404         MOV     A,#0x4
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   F0           MOVX    @DPTR,A
   2180          
   2181              // start EA processing
   2182              APSME_AuthenticateReq( &req );
   \   000038                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   AA82         MOV     R2,DPL
   \   000040   AB83         MOV     R3,DPH
   \   000042   12....       LCALL   ??APSME_AuthenticateReq?relay
   2183            }
   2184          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   000045   7407         MOV     A,#0x7
   \   000047   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004A   7F01         MOV     R7,#0x1
   \   00004C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2185          
   2186          /******************************************************************************
   2187           * @fn          ZDSecMgrAuthNwkKey
   2188           *
   2189           * @brief       Handle next step in authentication process
   2190           *
   2191           * @param       none
   2192           *
   2193           * @return      none
   2194           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2195          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2196          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2197            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   2198            {
   2199              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2200              {
   2201                uint8 parent[Z_EXTADDR_LEN];
   2202          
   2203                // get parent's EXT address
   2204                NLME_GetCoordExtAddr( parent );
   2205          
   2206                // begin entity authentication with parent
   2207                ZDSecMgrAuthInitiate( parent );
   2208              }
   2209              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2210              {
   2211                // inform ZDO that device has been authenticated
   2212                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay
   2213              }
   2214            }
   2215          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   D083         POP     DPH
   \   00001A   D082         POP     DPL
   \   00001C   02....       LJMP    ?BRET
   2216          
   2217          /******************************************************************************
   2218           * PUBLIC FUNCTIONS
   2219           */
   2220          /******************************************************************************
   2221           * @fn          ZDSecMgrInit
   2222           *
   2223           * @brief       Initialize ZigBee Device Security Manager.
   2224           *
   2225           * @param       none
   2226           *
   2227           * @return      none
   2228           */
   2229          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2230          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2231          void ZDSecMgrAddrMgrCB( uint8           update,
   2232                                  AddrMgrEntry_t* newEntry,
   2233                                  AddrMgrEntry_t* oldEntry )
   2234          {
   2235            (void)update;
   2236            (void)newEntry;
   2237            (void)oldEntry;
   2238          }
   2239          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2240          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2241          void ZDSecMgrInit( void )
   \                     ZDSecMgrInit:
   2242          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2243            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2244                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2245            {
   2246              // initialize sub modules
   2247              ZDSecMgrMasterKeyInit();
   2248              ZDSecMgrEntryInit();
   2249          
   2250              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2251              {
   2252                ZDSecMgrCtrlInit();
   2253              }
   2254          
   2255              // register with Address Manager
   2256              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2257              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2258              #endif
   2259            }
   2260          
   2261            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2262            {
   2263              // configure SKA slot data
   2264              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2265            }
   2266            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2267            {
   2268              // Setup the preconfig Trust Center Link Key
   2269              TrustCenterLinkKey.key = zgPreConfigTCLinkKey;
   2270              TrustCenterLinkKey.txFrmCntr = 0;
   2271              TrustCenterLinkKey.rxFrmCntr = 0;
   2272          #if defined ( NV_RESTORE )
   2273              if ( osal_nv_item_init( ZCD_NV_SECURE_TCLINKKEY_TXFRAME, sizeof(uint32), &(TrustCenterLinkKey.txFrmCntr) ) == ZSUCCESS )
   2274              {
   2275                osal_nv_read( ZCD_NV_SECURE_TCLINKKEY_TXFRAME, 0, sizeof(uint32), &(TrustCenterLinkKey.txFrmCntr) );
   2276              }
   2277              if ( osal_nv_item_init( ZCD_NV_SECURE_TCLINKKEY_RXFRAME, sizeof(uint32), &(TrustCenterLinkKey.rxFrmCntr) ) == ZSUCCESS )
   2278              {
   2279                osal_nv_read( ZCD_NV_SECURE_TCLINKKEY_RXFRAME, 0, sizeof(uint32), &(TrustCenterLinkKey.rxFrmCntr) );
   2280              }
   2281          #endif
   2282              APSME_TCLinkKeySetup( 0x0000, &TrustCenterLinkKey );
   2283            }
   2284          
   2285            if ( ZG_SECURE_ENABLED )
   2286            {
   2287              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2288              {
   2289                // setup joining permissions
   2290                ZDSecMgrPermitJoiningEnabled = TRUE;
   2291                ZDSecMgrPermitJoiningTimed   = FALSE;
   2292              }
   2293            }
   2294          
   2295            // configure security based on security mode and type of device
   2296            ZDSecMgrConfig();
   \   000004                ; Setup parameters for call to function ZDSecMgrConfig
   \   000004   12....       LCALL   ??ZDSecMgrConfig?relay
   2297          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   2298          
   2299          /******************************************************************************
   2300           * @fn          ZDSecMgrConfig
   2301           *
   2302           * @brief       Configure ZigBee Device Security Manager.
   2303           *
   2304           * @param       none
   2305           *
   2306           * @return      none
   2307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2308          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   2309          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2310            if ( ZG_SECURE_ENABLED )
   2311            {
   2312              SSP_Init();
   2313          
   2314              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2315                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2316              {
   2317                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2318                {
   2319                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2320                  APSME_SecurityCM_CD();
   2321                }
   2322                else if ( ZSTACK_ROUTER_BUILD )
   2323                {
   2324                  // COMMERCIAL MODE - ROUTER DEVICE
   2325                  APSME_SecurityCM_RD();
   2326                }
   2327                else
   2328                {
   2329                  // COMMERCIAL MODE - END DEVICE
   2330                  APSME_SecurityCM_ED();
   2331                }
   2332              }
   2333              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2334              {
   2335                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2336                {
   2337                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2338                  APSME_SecurityRM_CD();
   2339                }
   2340                else if ( ZSTACK_ROUTER_BUILD )
   2341                {
   2342                  // RESIDENTIAL MODE - ROUTER DEVICE
   2343                  APSME_SecurityRM_RD();
   2344                }
   2345                else
   2346                {
   2347                  // RESIDENTIAL MODE - END DEVICE
   2348                  APSME_SecurityRM_ED();
   2349                }
   2350              }
   2351            }
   2352            else
   2353            {
   2354              // NO SECURITY
   2355              APSME_SecurityNM();
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   ??APSME_SecurityNM?relay
   2356            }
   2357          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   2358          
   2359          /******************************************************************************
   2360           * @fn          ZDSecMgrPermitJoining
   2361           *
   2362           * @brief       Process request to change joining permissions.
   2363           *
   2364           * @param       duration - [in] timed duration for join in seconds
   2365           *                         - 0x00 not allowed
   2366           *                         - 0xFF allowed without timeout
   2367           *
   2368           * @return      uint8 - success(TRUE:FALSE)
   2369           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2370          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2371          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2372            uint8 accept;
   2373          
   2374          
   2375            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   2376          
   2377            if ( duration > 0 )
   \   00000B   E8           MOV     A,R0
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ      ??ZDSecMgrPermitJoining_0
   2378            {
   2379              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
   2380          
   2381              if ( duration != 0xFF )
   \   000014   74FF         MOV     A,#-0x1
   \   000016   68           XRL     A,R0
   \   000017   6009         JZ      ??ZDSecMgrPermitJoining_1
   2382              {
   2383                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV     A,#0x1
   \   00001E   8001         SJMP    ??ZDSecMgrPermitJoining_2
   2384              }
   2385            }
   2386            else
   2387            {
   2388              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR     A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX    @DPTR,A
   2389            }
   2390          
   2391            accept = TRUE;
   2392          
   2393            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV     R1,#0x1
   \   000024   D083         POP     DPH
   \   000026   D082         POP     DPL
   \   000028   02....       LJMP    ?BRET
   2394          }
   2395          
   2396          /******************************************************************************
   2397           * @fn          ZDSecMgrPermitJoiningTimeout
   2398           *
   2399           * @brief       Process permit joining timeout
   2400           *
   2401           * @param       none
   2402           *
   2403           * @return      none
   2404           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2405          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2406          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2407            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2408            {
   2409              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   2410              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   2411            }
   2412          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   02....       LJMP    ?BRET
   2413          
   2414          /******************************************************************************
   2415           * @fn          ZDSecMgrNewDeviceEvent
   2416           *
   2417           * @brief       Process a the new device event, if found reset new device
   2418           *              event/timer.
   2419           *
   2420           * @param       none
   2421           *
   2422           * @return      uint8 - found(TRUE:FALSE)
   2423           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2424          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2425          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2426            uint8                 found;
   2427            ZDSecMgrDevice_t      device;
   2428            AddrMgrEntry_t        addrEntry;
   2429            associated_devices_t* assoc;
   2430            ZStatus_t             status;
   2431          
   2432            // initialize return results
   2433            found = FALSE;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   2434          
   2435            // look for device in the security init state
   2436            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   ??AssocMatchDeviceStatus?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   AE..         MOV     R6,?V0 + 2
   \   000018   AF..         MOV     R7,?V0 + 3
   2437          
   2438            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   4F           ORL     A,R7
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2439            {
   2440              // device found
   2441              found = TRUE;
   \   000021   75..01       MOV     ?V0 + 0,#0x1
   2442          
   2443              // check for preconfigured security
   2444              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV     DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6401         XRL     A,#0x1
   \   00002A   7003         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2445              {
   2446                // set association status to authenticated
   2447                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2448              }
   2449          
   2450              // set up device info
   2451              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002F   740A         MOV     A,#0xa
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   2452              addrEntry.index = assoc->addrIdx;
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7415         MOV     A,#0x15
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   E8           MOV     A,R0
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   E9           MOV     A,R1
   \   00004A   F0           MOVX    @DPTR,A
   2453              AddrMgrEntryGet( &addrEntry );
   \   00004B                ; Setup parameters for call to function AddrMgrEntryGet
   \   00004B   740A         MOV     A,#0xa
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AA82         MOV     R2,DPL
   \   000052   AB83         MOV     R3,DPH
   \   000054   12....       LCALL   ??AddrMgrEntryGet?relay
   2454          
   2455              device.nwkAddr    = assoc->shortAddr;
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F8           MOV     R0,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   85..82       MOV     DPL,?XSP + 0
   \   000063   85..83       MOV     DPH,?XSP + 1
   \   000066   E8           MOV     A,R0
   \   000067   F0           MOVX    @DPTR,A
   \   000068   A3           INC     DPTR
   \   000069   E9           MOV     A,R1
   \   00006A   F0           MOVX    @DPTR,A
   2456              device.extAddr    = addrEntry.extAddr;
   \   00006B   740D         MOV     A,#0xd
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   A882         MOV     R0,DPL
   \   000072   A983         MOV     R1,DPH
   \   000074   7402         MOV     A,#0x2
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   E8           MOV     A,R0
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   E9           MOV     A,R1
   \   00007D   F0           MOVX    @DPTR,A
   2457              device.parentAddr = NLME_GetShortAddr();
   \   00007E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00007E   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   EA           MOV     A,R2
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   EB           MOV     A,R3
   \   00008A   F0           MOVX    @DPTR,A
   2458              device.secure     = FALSE;
   \   00008B   7406         MOV     A,#0x6
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   E4           CLR     A
   \   000091   F0           MOVX    @DPTR,A
   2459              device.devStatus  = assoc->devStatus;
   \   000092   EE           MOV     A,R6
   \   000093   2405         ADD     A,#0x5
   \   000095   FE           MOV     R6,A
   \   000096   EF           MOV     A,R7
   \   000097   3400         ADDC    A,#0x0
   \   000099   FF           MOV     R7,A
   \   00009A   8E82         MOV     DPL,R6
   \   00009C   8F83         MOV     DPH,R7
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   C0E0         PUSH    A
   \   0000A1   7407         MOV     A,#0x7
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   D0E0         POP     A
   \   0000A8   F0           MOVX    @DPTR,A
   2460          
   2461              // process new device
   2462              status = ZDSecMgrDeviceNew( &device );
   \   0000A9                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   0000A9   85..82       MOV     DPL,?XSP + 0
   \   0000AC   85..83       MOV     DPH,?XSP + 1
   \   0000AF   AA82         MOV     R2,DPL
   \   0000B1   AB83         MOV     R3,DPH
   \   0000B3   12....       LCALL   ??ZDSecMgrDeviceNew?relay
   \   0000B6   E9           MOV     A,R1
   \   0000B7   F8           MOV     R0,A
   2463          
   2464              if ( status == ZSuccess )
   \   0000B8   700A         JNZ     ??ZDSecMgrNewDeviceEvent_2
   2465              {
   2466                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   0000BA   8E82         MOV     DPL,R6
   \   0000BC   8F83         MOV     DPH,R7
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   C2E2         CLR     0xE0 /* A   */.2
   \   0000C1   F0           MOVX    @DPTR,A
   \   0000C2   8011         SJMP    ??ZDSecMgrNewDeviceEvent_0
   2467              }
   2468              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   0000C4   74C8         MOV     A,#-0x38
   \   0000C6   68           XRL     A,R0
   \   0000C7   700C         JNZ     ??ZDSecMgrNewDeviceEvent_0
   2469              {
   2470                AssocRemove( addrEntry.extAddr );
   \   0000C9                ; Setup parameters for call to function AssocRemove
   \   0000C9   740D         MOV     A,#0xd
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   AA82         MOV     R2,DPL
   \   0000D0   AB83         MOV     R3,DPH
   \   0000D2   12....       LCALL   ??AssocRemove?relay
   2471              }
   2472            }
   2473          
   2474            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000D5   A9..         MOV     R1,?V0 + 0
   \   0000D7   7417         MOV     A,#0x17
   \   0000D9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DC   7F04         MOV     R7,#0x4
   \   0000DE   02....       LJMP    ?BANKED_LEAVE_XDATA
   2475          }
   2476          
   2477          /******************************************************************************
   2478           * @fn          ZDSecMgrEvent
   2479           *
   2480           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2481           *
   2482           * @param       none
   2483           *
   2484           * @return      none
   2485           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2486          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2487          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2488            uint8            action;
   2489            uint8            restart;
   2490            uint16           index;
   2491            AddrMgrEntry_t   entry;
   2492            ZDSecMgrDevice_t device;
   2493          
   2494          
   2495            // verify data is available
   2496            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   7003         JNZ     $+5
   \   000016   02....       LJMP    ??ZDSecMgrEvent_0 & 0xFFFF
   2497            {
   2498              action  = FALSE;
   \   000019   75..00       MOV     ?V0 + 1,#0x0
   2499              restart = FALSE;
   \   00001C   75..00       MOV     ?V0 + 0,#0x0
   2500          
   2501              // update all the counters
   2502              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   \   000023   800B         SJMP    ??ZDSecMgrEvent_1
   2503              {
   2504                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   2505                {
   2506                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   2507                  {
   2508                    ZDSecMgrCtrlData[index].cntr--;
   2509                  }
   2510          
   2511                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   2512                  {
   2513                    action = TRUE;
   2514          
   2515                    // update from control data
   2516                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   2517                    device.secure     = ZDSecMgrCtrlData[index].secure;
   2518                    device.ctrl       = &ZDSecMgrCtrlData[index];
   2519          
   2520                    // set the user and address index
   2521                    entry.user  = ADDRMGR_USER_SECURITY;
   2522                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   2523          
   2524                    // get the address data
   2525                    AddrMgrEntryGet( &entry );
   2526          
   2527                    // set device address data
   2528                    device.nwkAddr = entry.nwkAddr;
   2529                    device.extAddr = entry.extAddr;
   2530          
   2531                    // update from entry data
   2532                    ZDSecMgrDeviceCtrlHandler( &device );
   2533                  }
   2534                  else
   2535                  {
   2536                    restart = TRUE;
   \                     ??ZDSecMgrEvent_2:
   \   000025   75..01       MOV     ?V0 + 0,#0x1
   2537                  }
   \                     ??ZDSecMgrEvent_3:
   \   000028   EE           MOV     A,R6
   \   000029   2401         ADD     A,#0x1
   \   00002B   0E           INC     R6
   \   00002C   EF           MOV     A,R7
   \   00002D   3400         ADDC    A,#0x0
   \   00002F   FF           MOV     R7,A
   \                     ??ZDSecMgrEvent_1:
   \   000030   C3           CLR     C
   \   000031   EE           MOV     A,R6
   \   000032   9403         SUBB    A,#0x3
   \   000034   EF           MOV     A,R7
   \   000035   9400         SUBB    A,#0x0
   \   000037   4003         JC      $+5
   \   000039   02....       LJMP    ??ZDSecMgrEvent_4 & 0xFFFF
   \   00003C   EE           MOV     A,R6
   \   00003D   F8           MOV     R0,A
   \   00003E   EF           MOV     A,R7
   \   00003F   F9           MOV     R1,A
   \   000040   E8           MOV     A,R0
   \   000041   75F007       MOV     B,#0x7
   \   000044   A4           MUL     AB
   \   000045   F8           MOV     R0,A
   \   000046   AAF0         MOV     R2,B
   \   000048   75F007       MOV     B,#0x7
   \   00004B   E9           MOV     A,R1
   \   00004C   A4           MUL     AB
   \   00004D   2A           ADD     A,R2
   \   00004E   F9           MOV     R1,A
   \   00004F   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000052   E0           MOVX    A,@DPTR
   \   000053   28           ADD     A,R0
   \   000054   FA           MOV     R2,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   39           ADDC    A,R1
   \   000058   FB           MOV     R3,A
   \   000059   8A82         MOV     DPL,R2
   \   00005B   8B83         MOV     DPH,R3
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   60C3         JZ      ??ZDSecMgrEvent_3
   \   000065   EA           MOV     A,R2
   \   000066   2406         ADD     A,#0x6
   \   000068   F582         MOV     DPL,A
   \   00006A   EB           MOV     A,R3
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F583         MOV     DPH,A
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   6003         JZ      ??ZDSecMgrEvent_5
   \   000072   E0           MOVX    A,@DPTR
   \   000073   14           DEC     A
   \   000074   F0           MOVX    @DPTR,A
   \                     ??ZDSecMgrEvent_5:
   \   000075   E5..         MOV     A,?V0 + 1
   \   000077   70AC         JNZ     ??ZDSecMgrEvent_2
   \   000079   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   28           ADD     A,R0
   \   00007E   F8           MOV     R0,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   39           ADDC    A,R1
   \   000082   F9           MOV     R1,A
   \   000083   8882         MOV     DPL,R0
   \   000085   8983         MOV     DPH,R1
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   7095         JNZ     ??ZDSecMgrEvent_2
   \   000090   75..01       MOV     ?V0 + 1,#0x1
   \   000093   8882         MOV     DPL,R0
   \   000095   8983         MOV     DPH,R1
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   FA           MOV     R2,A
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   FB           MOV     R3,A
   \   00009E   7404         MOV     A,#0x4
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   EA           MOV     A,R2
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   EB           MOV     A,R3
   \   0000A7   F0           MOVX    @DPTR,A
   \   0000A8   8882         MOV     DPL,R0
   \   0000AA   8983         MOV     DPH,R1
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   C0E0         PUSH    A
   \   0000B3   7406         MOV     A,#0x6
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   D0E0         POP     A
   \   0000BA   F0           MOVX    @DPTR,A
   \   0000BB   7408         MOV     A,#0x8
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   E8           MOV     A,R0
   \   0000C1   F0           MOVX    @DPTR,A
   \   0000C2   A3           INC     DPTR
   \   0000C3   E9           MOV     A,R1
   \   0000C4   F0           MOVX    @DPTR,A
   \   0000C5   740A         MOV     A,#0xa
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   7402         MOV     A,#0x2
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   8882         MOV     DPL,R0
   \   0000CF   8983         MOV     DPH,R1
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   F8           MOV     R0,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   F583         MOV     DPH,A
   \   0000D7   8882         MOV     DPL,R0
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   F8           MOV     R0,A
   \   0000DB   A3           INC     DPTR
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   F9           MOV     R1,A
   \   0000DE   7415         MOV     A,#0x15
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   E8           MOV     A,R0
   \   0000E4   F0           MOVX    @DPTR,A
   \   0000E5   A3           INC     DPTR
   \   0000E6   E9           MOV     A,R1
   \   0000E7   F0           MOVX    @DPTR,A
   \   0000E8                ; Setup parameters for call to function AddrMgrEntryGet
   \   0000E8   740A         MOV     A,#0xa
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   AA82         MOV     R2,DPL
   \   0000EF   AB83         MOV     R3,DPH
   \   0000F1   12....       LCALL   ??AddrMgrEntryGet?relay
   \   0000F4   740B         MOV     A,#0xb
   \   0000F6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   F8           MOV     R0,A
   \   0000FB   A3           INC     DPTR
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   F9           MOV     R1,A
   \   0000FE   85..82       MOV     DPL,?XSP + 0
   \   000101   85..83       MOV     DPH,?XSP + 1
   \   000104   E8           MOV     A,R0
   \   000105   F0           MOVX    @DPTR,A
   \   000106   A3           INC     DPTR
   \   000107   E9           MOV     A,R1
   \   000108   F0           MOVX    @DPTR,A
   \   000109   740D         MOV     A,#0xd
   \   00010B   12....       LCALL   ?XSTACK_DISP0_8
   \   00010E   A882         MOV     R0,DPL
   \   000110   A983         MOV     R1,DPH
   \   000112   7402         MOV     A,#0x2
   \   000114   12....       LCALL   ?XSTACK_DISP0_8
   \   000117   E8           MOV     A,R0
   \   000118   F0           MOVX    @DPTR,A
   \   000119   A3           INC     DPTR
   \   00011A   E9           MOV     A,R1
   \   00011B   F0           MOVX    @DPTR,A
   \   00011C                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   00011C   85..82       MOV     DPL,?XSP + 0
   \   00011F   85..83       MOV     DPH,?XSP + 1
   \   000122   AA82         MOV     R2,DPL
   \   000124   AB83         MOV     R3,DPH
   \   000126   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   \   000129   02....       LJMP    ??ZDSecMgrEvent_3 & 0xFFFF
   2538                }
   2539              }
   2540          
   2541              // check for timer restart
   2542              if ( restart == TRUE )
   \                     ??ZDSecMgrEvent_4:
   \   00012C   7401         MOV     A,#0x1
   \   00012E   65..         XRL     A,?V0 + 0
   \   000130   7010         JNZ     ??ZDSecMgrEvent_0
   2543              {
   2544                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   000132                ; Setup parameters for call to function osal_start_timerEx
   \   000132   7C64         MOV     R4,#0x64
   \   000134   7D00         MOV     R5,#0x0
   \   000136   7A00         MOV     R2,#0x0
   \   000138   7B01         MOV     R3,#0x1
   \   00013A   90....       MOV     DPTR,#ZDAppTaskID
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   F9           MOV     R1,A
   \   00013F   12....       LCALL   ??osal_start_timerEx?relay
   2545              }
   2546            }
   2547          }
   \                     ??ZDSecMgrEvent_0:
   \   000142   7417         MOV     A,#0x17
   \   000144   12....       LCALL   ?DEALLOC_XSTACK8
   \   000147   7F02         MOV     R7,#0x2
   \   000149   02....       LJMP    ?BANKED_LEAVE_XDATA
   2548          
   2549          /******************************************************************************
   2550           * @fn          ZDSecMgrEstablishKeyCfm
   2551           *
   2552           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2553           *
   2554           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2555           *
   2556           * @return      none
   2557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2558          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2559          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2560            // send the NWK key
   2561            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2562            {
   2563              // update control for specified EXT address
   2564              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2565            }
   2566            else
   2567            {
   2568              // this should be done when receiving the NWK key
   2569              // if devState ==
   2570              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2571                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2572          
   2573              // if not in joining state -- this should trigger an event for an
   2574              // end point that requested SKKE
   2575              // if ( devState == DEV_END_DEVICE )
   2576             //       devState == DEV_ROUTER;
   2577          
   2578            }
   2579          }
   \   000000   02....       LJMP    ?BRET
   2580          
   2581          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2582          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2583          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2584            uint8  match;
   2585            uint8  lookup[Z_EXTADDR_LEN];
   2586          
   2587            match = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2588          
   2589            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000022   E9           MOV     A,R1
   \   000023   6014         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2590            {
   2591              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   000025                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   2592            }
   2593          
   2594            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   000039   A9..         MOV     R1,?V0 + 0
   \   00003B   7408         MOV     A,#0x8
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000040   7F01         MOV     R7,#0x1
   \   000042   02....       LJMP    ?BANKED_LEAVE_XDATA
   2595          }
   2596          
   2597          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2598          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2599          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2600            uint16 ami;
   2601            uint8* key;
   2602          
   2603            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   705E         JNZ     ??ZDSecMgrTCDataLoad_0
   2604            {
   2605              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   8582..       MOV     ?V0 + 0,DPL
   \   000019   8583..       MOV     ?V0 + 1,DPH
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   EA           MOV     A,R2
   \   000022   FC           MOV     R4,A
   \   000023   EB           MOV     A,R3
   \   000024   FD           MOV     R5,A
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7B00         MOV     R3,#0x0
   \   000029   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002C   7402         MOV     A,#0x2
   \   00002E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000031   E9           MOV     A,R1
   \   000032   7034         JNZ     ??ZDSecMgrTCDataLoad_1
   2606              {
   2607                // if preconfigured load key
   2608                if ( zgPreConfigKeys == TRUE )
   \   000034   90....       MOV     DPTR,#zgPreConfigKeys
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6401         XRL     A,#0x1
   \   00003A   702C         JNZ     ??ZDSecMgrTCDataLoad_1
   2609                {
   2610                  if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   \   00003C                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   AC82         MOV     R4,DPL
   \   000043   AD83         MOV     R5,DPH
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   FA           MOV     R2,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   FB           MOV     R3,A
   \   000050   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000053   E9           MOV     A,R1
   \   000054   6012         JZ      ??ZDSecMgrTCDataLoad_1
   2611                  {
   2612                    ZDSecMgrMasterKeyStore( ami, ZDSecMgrTCMasterKey );
   \   000056                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000056   7C..         MOV     R4,#ZDSecMgrTCMasterKey & 0xff
   \   000058   7D..         MOV     R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00005A   85..82       MOV     DPL,?XSP + 0
   \   00005D   85..83       MOV     DPH,?XSP + 1
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FA           MOV     R2,A
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   FB           MOV     R3,A
   \   000065   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   2613                  }
   2614                }
   2615              }
   2616          
   2617              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??ZDSecMgrTCDataLoad_1:
   \   000068   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   00006B   7401         MOV     A,#0x1
   \   00006D   F0           MOVX    @DPTR,A
   2618            }
   2619          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   00006E   7404         MOV     A,#0x4
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   \   000073   7F02         MOV     R7,#0x2
   \   000075   02....       LJMP    ?BANKED_LEAVE_XDATA
   2620          
   2621          /******************************************************************************
   2622           * @fn          ZDSecMgrEstablishKeyInd
   2623           *
   2624           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2625           *
   2626           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2627           *
   2628           * @return      none
   2629           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2630          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2631          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2632            ZDSecMgrDevice_t        device;
   2633            APSME_EstablishKeyRsp_t rsp;
   2634          
   2635          
   2636            // load Trust Center data if needed
   2637            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   EE           MOV     A,R6
   \   00000F   2404         ADD     A,#0x4
   \   000011   F5..         MOV     ?V0 + 0,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000018   AA..         MOV     R2,?V0 + 0
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2638          
   2639            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   00001E   EE           MOV     A,R6
   \   00001F   2402         ADD     A,#0x2
   \   000021   F5..         MOV     ?V0 + 2,A
   \   000023   EF           MOV     A,R7
   \   000024   3400         ADDC    A,#0x0
   \   000026   F5..         MOV     ?V0 + 3,A
   \   000028                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   000028   AA..         MOV     R2,?V0 + 0
   \   00002A   AB..         MOV     R3,?V0 + 1
   \   00002C   12....       LCALL   ??ZDSecMgrTCExtAddrCheck?relay
   \   00002F   E9           MOV     A,R1
   \   000030   601F         JZ      ??ZDSecMgrEstablishKeyInd_0
   2640            {
   2641              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2642              //OR
   2643              //!ZDSecMgrTCAuthenticated
   2644              //devtag.0604.critical
   2645                  //how is the parentAddr used here
   2646          
   2647              // initial SKKE from Trust Center via parent
   2648              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000032   7407         MOV     A,#0x7
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   E4           CLR     A
   \   000038   F0           MOVX    @DPTR,A
   \   000039   A3           INC     DPTR
   \   00003A   F0           MOVX    @DPTR,A
   2649              device.parentAddr = ind->srcAddr;
   \   00003B   85..82       MOV     DPL,?V0 + 2
   \   00003E   85..83       MOV     DPH,?V0 + 3
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F8           MOV     R0,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F9           MOV     R1,A
   \   000046   740B         MOV     A,#0xb
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   E8           MOV     A,R0
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   E9           MOV     A,R1
   \   00004F   801F         SJMP    ??ZDSecMgrEstablishKeyInd_1
   2650            }
   2651            else
   2652            {
   2653              // Trust Center direct or E2E SKKE
   2654              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   000051   85..82       MOV     DPL,?V0 + 2
   \   000054   85..83       MOV     DPH,?V0 + 3
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F8           MOV     R0,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F9           MOV     R1,A
   \   00005C   7407         MOV     A,#0x7
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   E8           MOV     A,R0
   \   000062   F0           MOVX    @DPTR,A
   \   000063   A3           INC     DPTR
   \   000064   E9           MOV     A,R1
   \   000065   F0           MOVX    @DPTR,A
   2655              device.parentAddr = INVALID_NODE_ADDR;
   \   000066   740B         MOV     A,#0xb
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   74FE         MOV     A,#-0x2
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   A3           INC     DPTR
   \   00006F   04           INC     A
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000070   F0           MOVX    @DPTR,A
   2656            }
   2657          
   2658            device.extAddr = ind->initExtAddr;
   \   000071   7409         MOV     A,#0x9
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   E5..         MOV     A,?V0 + 0
   \   000078   F0           MOVX    @DPTR,A
   \   000079   A3           INC     DPTR
   \   00007A   E5..         MOV     A,?V0 + 1
   \   00007C   F0           MOVX    @DPTR,A
   2659            //devtag.pro.security.0724.todo - verify usage
   2660            device.secure  = ind->nwkSecure;
   \   00007D   EE           MOV     A,R6
   \   00007E   240E         ADD     A,#0xe
   \   000080   F5..         MOV     ?V0 + 0,A
   \   000082   EF           MOV     A,R7
   \   000083   3400         ADDC    A,#0x0
   \   000085   F5..         MOV     ?V0 + 1,A
   \   000087   85..82       MOV     DPL,?V0 + 0
   \   00008A   F583         MOV     DPH,A
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   C0E0         PUSH    A
   \   00008F   740D         MOV     A,#0xd
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   D0E0         POP     A
   \   000096   F0           MOVX    @DPTR,A
   2661          
   2662            // validate device for SKKE
   2663            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000097                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000097   7407         MOV     A,#0x7
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   AA82         MOV     R2,DPL
   \   00009E   AB83         MOV     R3,DPH
   \   0000A0   12....       LCALL   ??ZDSecMgrDeviceValidateSKKE?relay
   \   0000A3   E9           MOV     A,R1
   \   0000A4   7009         JNZ     ??ZDSecMgrEstablishKeyInd_2
   2664            {
   2665              rsp.accept = TRUE;
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   7401         MOV     A,#0x1
   \   0000AD   8006         SJMP    ??ZDSecMgrEstablishKeyInd_3
   2666            }
   2667            else
   2668            {
   2669              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   0000AF   7404         MOV     A,#0x4
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   E4           CLR     A
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   0000B5   F0           MOVX    @DPTR,A
   2670            }
   2671          
   2672            rsp.dstAddr     = ind->srcAddr;
   \   0000B6   85..82       MOV     DPL,?V0 + 2
   \   0000B9   85..83       MOV     DPH,?V0 + 3
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F8           MOV     R0,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   F9           MOV     R1,A
   \   0000C1   85..82       MOV     DPL,?XSP + 0
   \   0000C4   85..83       MOV     DPH,?XSP + 1
   \   0000C7   E8           MOV     A,R0
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E9           MOV     A,R1
   \   0000CB   F0           MOVX    @DPTR,A
   2673            rsp.initExtAddr = &ind->initExtAddr[0];
   \   0000CC   EE           MOV     A,R6
   \   0000CD   2404         ADD     A,#0x4
   \   0000CF   F8           MOV     R0,A
   \   0000D0   EF           MOV     A,R7
   \   0000D1   3400         ADDC    A,#0x0
   \   0000D3   F9           MOV     R1,A
   \   0000D4   7402         MOV     A,#0x2
   \   0000D6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D9   E8           MOV     A,R0
   \   0000DA   F0           MOVX    @DPTR,A
   \   0000DB   A3           INC     DPTR
   \   0000DC   E9           MOV     A,R1
   \   0000DD   F0           MOVX    @DPTR,A
   2674            //devtag.0604.todo - remove obsolete
   2675            rsp.apsSecure   = ind->apsSecure;
   \   0000DE   EE           MOV     A,R6
   \   0000DF   240D         ADD     A,#0xd
   \   0000E1   F582         MOV     DPL,A
   \   0000E3   EF           MOV     A,R7
   \   0000E4   3400         ADDC    A,#0x0
   \   0000E6   F583         MOV     DPH,A
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   C0E0         PUSH    A
   \   0000EB   7405         MOV     A,#0x5
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   D0E0         POP     A
   \   0000F2   F0           MOVX    @DPTR,A
   2676            rsp.nwkSecure   = ind->nwkSecure;
   \   0000F3   85..82       MOV     DPL,?V0 + 0
   \   0000F6   85..83       MOV     DPH,?V0 + 1
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   C0E0         PUSH    A
   \   0000FC   7406         MOV     A,#0x6
   \   0000FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000101   D0E0         POP     A
   \   000103   F0           MOVX    @DPTR,A
   2677          
   2678            APSME_EstablishKeyRsp( &rsp );
   \   000104                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000104   85..82       MOV     DPL,?XSP + 0
   \   000107   85..83       MOV     DPH,?XSP + 1
   \   00010A   AA82         MOV     R2,DPL
   \   00010C   AB83         MOV     R3,DPH
   \   00010E   12....       LCALL   ??APSME_EstablishKeyRsp?relay
   2679          }
   \   000111   7411         MOV     A,#0x11
   \   000113   12....       LCALL   ?DEALLOC_XSTACK8
   \   000116   7F04         MOV     R7,#0x4
   \   000118   02....       LJMP    ?BANKED_LEAVE_XDATA
   2680          //devtag.pro.security
   2681          #if 0
   2682          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2683          {
   2684            ZDSecMgrDevice_t        device;
   2685            APSME_EstablishKeyRsp_t rsp;
   2686          
   2687          
   2688            device.extAddr = ind->initExtAddr;
   2689            device.secure  = ind->secure;
   2690          
   2691            if ( ind->secure == FALSE )
   2692            {
   2693              // SKKE from Trust Center is not secured between child and parent
   2694              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2695              device.parentAddr = ind->srcAddr;
   2696            }
   2697            else
   2698            {
   2699              // SKKE from initiator should be secured
   2700              device.nwkAddr    = ind->srcAddr;
   2701              device.parentAddr = INVALID_NODE_ADDR;
   2702            }
   2703          
   2704            rsp.dstAddr     = ind->srcAddr;
   2705            rsp.initExtAddr = &ind->initExtAddr[0];
   2706            rsp.secure      = ind->secure;
   2707          
   2708            // validate device for SKKE
   2709            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2710            {
   2711              rsp.accept = TRUE;
   2712            }
   2713            else
   2714            {
   2715              rsp.accept = FALSE;
   2716            }
   2717          
   2718            APSME_EstablishKeyRsp( &rsp );
   2719          }
   2720          #endif
   2721          
   2722          /******************************************************************************
   2723           * @fn          ZDSecMgrTransportKeyInd
   2724           *
   2725           * @brief       Process the ZDO_TransportKeyInd_t message.
   2726           *
   2727           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2728           *
   2729           * @return      none
   2730           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2731          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2732          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2733            uint8 index;
   2734          
   2735            // load Trust Center data if needed
   2736            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   000009                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000009   EE           MOV     A,R6
   \   00000A   2416         ADD     A,#0x16
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   3400         ADDC    A,#0x0
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2737          
   2738            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000014   EE           MOV     A,R6
   \   000015   2404         ADD     A,#0x4
   \   000017   F582         MOV     DPL,A
   \   000019   EF           MOV     A,R7
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F583         MOV     DPH,A
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6077         JZ      ??ZDSecMgrTransportKeyInd_0
   2739            {
   2740              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2741              //ZDSecMgrTCMasterKey( ind );
   2742              {
   2743                if ( zgPreConfigKeys != TRUE )
   2744                {
   2745                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2746                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2747                }
   2748                else
   2749                {
   2750                  // error condition - reject key
   2751                }
   2752              }
   2753            }
   2754            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2755                      ( ind->keyType == 6                 ) ||
   2756                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000021   E0           MOVX    A,@DPTR
   \   000022   6401         XRL     A,#0x1
   \   000024   600A         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   6406         XRL     A,#0x6
   \   000029   6005         JZ      ??ZDSecMgrTransportKeyInd_1
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   6405         XRL     A,#0x5
   \   00002E   7068         JNZ     ??ZDSecMgrTransportKeyInd_0
   2757            {
   2758              // check for dummy NWK key (all zeros)
   2759              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000030   7800         MOV     R0,#0x0
   \   000032   8001         SJMP    ??ZDSecMgrTransportKeyInd_2
   2760                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2761                    index++ );
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000034   08           INC     R0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   000035   E8           MOV     A,R0
   \   000036   C3           CLR     C
   \   000037   9410         SUBB    A,#0x10
   \   000039   5015         JNC     ??ZDSecMgrTransportKeyInd_4
   \   00003B   88..         MOV     ?V0 + 0,R0
   \   00003D   EE           MOV     A,R6
   \   00003E   25..         ADD     A,?V0 + 0
   \   000040   F582         MOV     DPL,A
   \   000042   EF           MOV     A,R7
   \   000043   3400         ADDC    A,#0x0
   \   000045   F583         MOV     DPH,A
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   60E4         JZ      ??ZDSecMgrTransportKeyInd_3
   2762          
   2763              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000050   7410         MOV     A,#0x10
   \   000052   68           XRL     A,R0
   \   000053   7013         JNZ     ??ZDSecMgrTransportKeyInd_5
   2764              {
   2765                // load preconfigured key - once!!
   2766                if ( !_NIB.nwkKeyLoaded )
   \   000055   90....       MOV     DPTR,#_NIB + 61
   \   000058   E0           MOVX    A,@DPTR
   \   000059   703A         JNZ     ??ZDSecMgrTransportKeyInd_6
   2767                {
   2768                  SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
   \   00005B                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   00005B   7900         MOV     R1,#0x0
   \   00005D   7A..         MOV     R2,#zgPreConfigKey & 0xff
   \   00005F   7B..         MOV     R3,#(zgPreConfigKey >> 8) & 0xff
   \   000061   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2769                  SSP_SwitchNwkKey( 0 );
   \   000064                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000064   7900         MOV     R1,#0x0
   \   000066   802A         SJMP    ??ZDSecMgrTransportKeyInd_7
   2770                }
   2771              }
   2772              else
   2773              {
   2774                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   000068   EE           MOV     A,R6
   \   000069   2405         ADD     A,#0x5
   \   00006B   F5..         MOV     ?V0 + 0,A
   \   00006D   EF           MOV     A,R7
   \   00006E   3400         ADDC    A,#0x0
   \   000070   F5..         MOV     ?V0 + 1,A
   \   000072                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000072   85..82       MOV     DPL,?V0 + 0
   \   000075   F583         MOV     DPH,A
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F9           MOV     R1,A
   \   000079   EE           MOV     A,R6
   \   00007A   2406         ADD     A,#0x6
   \   00007C   FA           MOV     R2,A
   \   00007D   EF           MOV     A,R7
   \   00007E   3400         ADDC    A,#0x0
   \   000080   FB           MOV     R3,A
   \   000081   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2775                if ( !_NIB.nwkKeyLoaded )
   \   000084   90....       MOV     DPTR,#_NIB + 61
   \   000087   E0           MOVX    A,@DPTR
   \   000088   700B         JNZ     ??ZDSecMgrTransportKeyInd_6
   2776                {
   2777                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   00008A                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00008A   85..82       MOV     DPL,?V0 + 0
   \   00008D   85..83       MOV     DPH,?V0 + 1
   \   000090   E0           MOVX    A,@DPTR
   \   000091   F9           MOV     R1,A
   \                     ??ZDSecMgrTransportKeyInd_7:
   \   000092   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2778                }
   2779              }
   2780          
   2781              // handle next step in authentication process
   2782              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   000095                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   000095   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay
   2783            }
   2784            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2785            {
   2786              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2787              {
   2788                //ZDSecMgrTCLinkKey( ind );
   2789              }
   2790            }
   2791            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2792            {
   2793              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2794              {
   2795                uint16           ami;
   2796                AddrMgrEntry_t   entry;
   2797                ZDSecMgrEntry_t* entryZD;
   2798          
   2799                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2800          
   2801                if ( ind->initiator == TRUE )
   2802                {
   2803                  // get the ami data
   2804                  entry.user  = ADDRMGR_USER_SECURITY;
   2805                  entry.index = ami;
   2806                  AddrMgrEntryGet( &entry );
   2807          
   2808                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2809                  {
   2810                    APSME_EstablishKeyReq_t req;
   2811                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2812          
   2813                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2814          
   2815                    if ( entryZD == NULL )
   2816                    {
   2817                      // get new entry
   2818                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2819                      {
   2820                        // finish setting up entry
   2821                        entryZD->ami = ami;
   2822                      }
   2823                    }
   2824          
   2825                    req.respExtAddr = ind->srcExtAddr;
   2826                    req.method      = APSME_SKKE_METHOD;
   2827                    req.dstAddr     = entry.nwkAddr;
   2828                    //devtag.0604.todo - remove obsolete
   2829                    req.apsSecure   = FALSE;
   2830                    req.nwkSecure   = TRUE;
   2831                    APSME_EstablishKeyReq( &req );
   2832                  }
   2833                }
   2834                else
   2835                {
   2836                  if ( ami == INVALID_NODE_ADDR )
   2837                  {
   2838                    // store new EXT address
   2839                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2840                  }
   2841          
   2842                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2843                }
   2844          
   2845                //if ( entry.nwkAddr == INVALID_NODE_ADDR )
   2846                //{
   2847                //  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2848                //}
   2849              }
   2850            }
   2851            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2852            {
   2853              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2854              {
   2855                uint16           ami;
   2856                ZDSecMgrEntry_t* entry;
   2857          
   2858                // get the address index
   2859                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2860                {
   2861                  // store new EXT address
   2862                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2863                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2864                }
   2865          
   2866                ZDSecMgrEntryLookupAMI( ami, &entry );
   2867          
   2868                if ( entry == NULL )
   2869                {
   2870                  // get new entry
   2871                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2872                  {
   2873                    // finish setting up entry
   2874                    entry->ami = ami;
   2875                  }
   2876                }
   2877          
   2878                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2879              }
   2880            }
   2881          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   000098   7F02         MOV     R7,#0x2
   \   00009A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2882          
   2883          /******************************************************************************
   2884           * @fn          ZDSecMgrUpdateDeviceInd
   2885           *
   2886           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2887           *
   2888           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2889           *
   2890           * @return      none
   2891           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2892          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2893          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2894            ZDSecMgrDevice_t device;
   2895          
   2896          
   2897            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV     A,R2
   \   00000A   240C         ADD     A,#0xc
   \   00000C   F582         MOV     DPL,A
   \   00000E   EB           MOV     A,R3
   \   00000F   3400         ADDC    A,#0x0
   \   000011   F583         MOV     DPH,A
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   E8           MOV     A,R0
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   E9           MOV     A,R1
   \   000022   F0           MOVX    @DPTR,A
   2898            device.extAddr    = ind->devExtAddr;
   \   000023   EA           MOV     A,R2
   \   000024   2404         ADD     A,#0x4
   \   000026   F8           MOV     R0,A
   \   000027   EB           MOV     A,R3
   \   000028   3400         ADDC    A,#0x0
   \   00002A   F9           MOV     R1,A
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E8           MOV     A,R0
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   E9           MOV     A,R1
   \   000034   F0           MOVX    @DPTR,A
   2899            device.parentAddr = ind->srcAddr;
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F9           MOV     R1,A
   \   000040   7404         MOV     A,#0x4
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E8           MOV     A,R0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E9           MOV     A,R1
   \   000049   F0           MOVX    @DPTR,A
   2900          
   2901            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2902            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2903            //{
   2904            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2905            //  {
   2906            //    device.secure = TRUE;
   2907            //  }
   2908            //  else
   2909            //  {
   2910            //    device.secure = FALSE;
   2911            //  }
   2912          
   2913              // try to join this device
   2914              ZDSecMgrDeviceJoin( &device );
   \   00004A                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   AA82         MOV     R2,DPL
   \   000052   AB83         MOV     R3,DPH
   \   000054   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   2915            //}
   2916          }
   \   000057   740A         MOV     A,#0xa
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   D083         POP     DPH
   \   00005E   D082         POP     DPL
   \   000060   02....       LJMP    ?BRET
   2917          
   2918          /******************************************************************************
   2919           * @fn          ZDSecMgrRemoveDeviceInd
   2920           *
   2921           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2922           *
   2923           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2924           *
   2925           * @return      none
   2926           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2927          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2928          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2929            ZDSecMgrDevice_t device;
   2930          
   2931          
   2932            // only accept from Trust Center
   2933            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F8           MOV     R0,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   49           ORL     A,R1
   \   000017   7042         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2934            {
   2935              // look up NWK address
   2936              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000019   EA           MOV     A,R2
   \   00001A   2404         ADD     A,#0x4
   \   00001C   FE           MOV     R6,A
   \   00001D   EB           MOV     A,R3
   \   00001E   3400         ADDC    A,#0x0
   \   000020   FF           MOV     R7,A
   \   000021                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   AC82         MOV     R4,DPL
   \   000029   AD83         MOV     R5,DPH
   \   00002B   EE           MOV     A,R6
   \   00002C   FA           MOV     R2,A
   \   00002D   EF           MOV     A,R7
   \   00002E   FB           MOV     R3,A
   \   00002F   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000032   E9           MOV     A,R1
   \   000033   6401         XRL     A,#0x1
   \   000035   7024         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2937              {
   2938                device.parentAddr = NLME_GetShortAddr();
   \   000037                ; Setup parameters for call to function NLME_GetShortAddr
   \   000037   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   EA           MOV     A,R2
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   EB           MOV     A,R3
   \   000043   F0           MOVX    @DPTR,A
   2939                device.extAddr    = ind->childExtAddr;
   \   000044   7402         MOV     A,#0x2
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   EE           MOV     A,R6
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   EF           MOV     A,R7
   \   00004D   F0           MOVX    @DPTR,A
   2940          
   2941                // remove device
   2942                ZDSecMgrDeviceRemove( &device );
   \   00004E                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   AA82         MOV     R2,DPL
   \   000056   AB83         MOV     R3,DPH
   \   000058   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2943              }
   2944            }
   2945          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   00005B   740A         MOV     A,#0xa
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000060   7F01         MOV     R7,#0x1
   \   000062   02....       LJMP    ?BANKED_LEAVE_XDATA
   2946          
   2947          /******************************************************************************
   2948           * @fn          ZDSecMgrRequestKeyInd
   2949           *
   2950           * @brief       Process the ZDO_RequestKeyInd_t message.
   2951           *
   2952           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2953           *
   2954           * @return      none
   2955           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2956          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2957          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2958            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   EA           MOV     A,R2
   \   000005   2404         ADD     A,#0x4
   \   000007   F582         MOV     DPL,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F583         MOV     DPH,A
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   6401         XRL     A,#0x1
   \   000011   6008         JZ      ??ZDSecMgrRequestKeyInd_0
   2959            {
   2960            }
   2961            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   E0           MOVX    A,@DPTR
   \   000014   6402         XRL     A,#0x2
   \   000016   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   2962            {
   2963              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL   ??ZDSecMgrAppKeyReq?relay
   2964            }
   2965            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2966            {
   2967            }
   2968            //else ignore
   2969          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   02....       LJMP    ?BRET
   2970          
   2971          /******************************************************************************
   2972           * @fn          ZDSecMgrSwitchKeyInd
   2973           *
   2974           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2975           *
   2976           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2977           *
   2978           * @return      none
   2979           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2980          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2981          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2982            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2983          
   2984            // Save if nv
   2985            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   ??ZDApp_NVUpdate?relay
   2986          }
   \   000014   D083         POP     DPH
   \   000016   D082         POP     DPL
   \   000018   02....       LJMP    ?BRET
   2987          
   2988          /******************************************************************************
   2989           * @fn          ZDSecMgrAuthenticateInd
   2990           *
   2991           * @brief       Process the ZDO_AuthenticateInd_t message.
   2992           *
   2993           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2994           *
   2995           * @return      none
   2996           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2997          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   2998          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2999            APSME_AuthenticateReq_t req;
   3000            AddrMgrEntry_t          entry;
   3001          
   3002          
   3003            // update the address manager
   3004            //---------------------------------------------------------------------------
   3005            // note:
   3006            // required for EA processing, but ultimately EA logic could also use the
   3007            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3008            // table is supposed to have authentication states for neighbors
   3009            //---------------------------------------------------------------------------
   3010            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
   3011            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   EE           MOV     A,R6
   \   000017   2402         ADD     A,#0x2
   \   000019   F5..         MOV     ?V0 + 2,A
   \   00001B   EF           MOV     A,R7
   \   00001C   3400         ADDC    A,#0x0
   \   00001E   F5..         MOV     ?V0 + 3,A
   \   000020   85..82       MOV     DPL,?V0 + 2
   \   000023   F583         MOV     DPH,A
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F8           MOV     R0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   7408         MOV     A,#0x8
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E8           MOV     A,R0
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   E9           MOV     A,R1
   \   000033   F0           MOVX    @DPTR,A
   3012            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \   000034   EE           MOV     A,R6
   \   000035   2404         ADD     A,#0x4
   \   000037   F5..         MOV     ?V0 + 0,A
   \   000039   EF           MOV     A,R7
   \   00003A   3400         ADDC    A,#0x0
   \   00003C   F5..         MOV     ?V0 + 1,A
   \   00003E                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00003E   AC..         MOV     R4,?V0 + 0
   \   000040   FD           MOV     R5,A
   \   000041   740A         MOV     A,#0xa
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   AA82         MOV     R2,DPL
   \   000048   AB83         MOV     R3,DPH
   \   00004A   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3013          
   3014            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00004D                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00004D   7407         MOV     A,#0x7
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   AA82         MOV     R2,DPL
   \   000054   AB83         MOV     R3,DPH
   \   000056   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000059   E9           MOV     A,R1
   \   00005A   6401         XRL     A,#0x1
   \   00005C   7049         JNZ     ??ZDSecMgrAuthenticateInd_0
   3015            {
   3016              // set request fields
   3017              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00005E   85..82       MOV     DPL,?V0 + 2
   \   000061   85..83       MOV     DPH,?V0 + 3
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F8           MOV     R0,A
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   F9           MOV     R1,A
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   E8           MOV     A,R0
   \   000070   F0           MOVX    @DPTR,A
   \   000071   A3           INC     DPTR
   \   000072   E9           MOV     A,R1
   \   000073   F0           MOVX    @DPTR,A
   3018              req.extAddr   = ind->aps.initExtAddr;
   \   000074   7402         MOV     A,#0x2
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   E5..         MOV     A,?V0 + 0
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   E5..         MOV     A,?V0 + 1
   \   00007F   F0           MOVX    @DPTR,A
   3019              req.action    = APSME_EA_ACCEPT;
   \   000080   7406         MOV     A,#0x6
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   7401         MOV     A,#0x1
   \   000087   F0           MOVX    @DPTR,A
   3020              req.challenge = ind->aps.challenge;
   \   000088   EE           MOV     A,R6
   \   000089   240C         ADD     A,#0xc
   \   00008B   F8           MOV     R0,A
   \   00008C   EF           MOV     A,R7
   \   00008D   3400         ADDC    A,#0x0
   \   00008F   F9           MOV     R1,A
   \   000090   7404         MOV     A,#0x4
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   E8           MOV     A,R0
   \   000096   F0           MOVX    @DPTR,A
   \   000097   A3           INC     DPTR
   \   000098   E9           MOV     A,R1
   \   000099   F0           MOVX    @DPTR,A
   3021          
   3022              // start EA processing
   3023              APSME_AuthenticateReq( &req );
   \   00009A                ; Setup parameters for call to function APSME_AuthenticateReq
   \   00009A   85..82       MOV     DPL,?XSP + 0
   \   00009D   85..83       MOV     DPH,?XSP + 1
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ??APSME_AuthenticateReq?relay
   3024            }
   3025          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   0000A7   7414         MOV     A,#0x14
   \   0000A9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AC   7F04         MOV     R7,#0x4
   \   0000AE   02....       LJMP    ?BANKED_LEAVE_XDATA
   3026          
   3027          /******************************************************************************
   3028           * @fn          ZDSecMgrAuthenticateCfm
   3029           *
   3030           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3031           *
   3032           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3033           *
   3034           * @return      none
   3035           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3036          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3037          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3038            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV     A,R2
   \   000005   240B         ADD     A,#0xb
   \   000007   F582         MOV     DPL,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F583         MOV     DPH,A
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   701F         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3039            {
   3040              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   7014         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   00001C   90....       MOV     DPTR,#devState
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6405         XRL     A,#0x5
   \   000022   700C         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3041              {
   3042                // inform ZDO that device has been authenticated
   3043                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000024                ; Setup parameters for call to function osal_set_event
   \   000024   7A80         MOV     R2,#-0x80
   \   000026   7B00         MOV     R3,#0x0
   \   000028   90....       MOV     DPTR,#ZDAppTaskID
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   12....       LCALL   ??osal_set_event?relay
   3044              }
   3045            }
   3046          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   000030   D083         POP     DPH
   \   000032   D082         POP     DPL
   \   000034   02....       LJMP    ?BRET
   3047          
   3048          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3049          /******************************************************************************
   3050           * @fn          ZDSecMgrUpdateNwkKey
   3051           *
   3052           * @brief       Load a new NWK key and trigger a network wide update.
   3053           *
   3054           * @param       key       - [in] new NWK key
   3055           * @param       keySeqNum - [in] new NWK key sequence number
   3056           *
   3057           * @return      ZStatus_t
   3058           */
   3059          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3060          {
   3061            ZStatus_t               status;
   3062            APSME_TransportKeyReq_t req;
   3063          
   3064            // initialize common elements of local variables
   3065            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3066              req.keyType   = KEY_TYPE_NWK_HIGH;
   3067            else
   3068              req.keyType   = KEY_TYPE_NWK;
   3069          
   3070            req.dstAddr   = dstAddr;
   3071            req.keySeqNum = keySeqNum;
   3072            req.key       = key;
   3073            req.extAddr   = NULL;
   3074            req.nwkSecure = TRUE;
   3075            req.apsSecure = TRUE;
   3076            req.tunnel    = NULL;
   3077          
   3078            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3079            {
   3080              ZDSecMgrEntry_t*        entry;
   3081              uint16                  index;
   3082              AddrMgrEntry_t          addrEntry;
   3083          
   3084              addrEntry.user = ADDRMGR_USER_SECURITY;
   3085          
   3086              status = ZFailure;
   3087          
   3088              // verify data is available
   3089              if ( ZDSecMgrEntries != NULL )
   3090              {
   3091                // find available entry
   3092                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3093                {
   3094                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3095                  {
   3096                    // return successful result
   3097                    entry = &ZDSecMgrEntries[index];
   3098          
   3099                    // get NWK address
   3100                    addrEntry.index = entry->ami;
   3101                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3102                    {
   3103                      req.dstAddr = addrEntry.nwkAddr;
   3104                      req.extAddr = addrEntry.extAddr;
   3105                      status = APSME_TransportKeyReq( &req );
   3106                    }
   3107                  }
   3108                }
   3109              }
   3110            }
   3111            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3112            {
   3113              status = APSME_TransportKeyReq( &req );
   3114            }
   3115          
   3116            SSP_UpdateNwkKey( key, keySeqNum );
   3117          
   3118            // Save if nv
   3119            ZDApp_NVUpdate();
   3120          
   3121            return status;
   3122          }
   3123          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3124          
   3125          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3126          /******************************************************************************
   3127           * @fn          ZDSecMgrSwitchNwkKey
   3128           *
   3129           * @brief       Causes the NWK key to switch via a network wide command.
   3130           *
   3131           * @param       keySeqNum - [in] new NWK key sequence number
   3132           *
   3133           * @return      ZStatus_t
   3134           */
   3135          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3136          {
   3137            ZStatus_t            status;
   3138            APSME_SwitchKeyReq_t req;
   3139          
   3140            // initialize common elements of local variables
   3141            req.dstAddr = dstAddr;
   3142            req.keySeqNum = keySeqNum;
   3143          
   3144            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3145            {
   3146              ZDSecMgrEntry_t*     entry;
   3147              uint16               index;
   3148              AddrMgrEntry_t       addrEntry;
   3149          
   3150              addrEntry.user = ADDRMGR_USER_SECURITY;
   3151          
   3152              status = ZFailure;
   3153          
   3154              // verify data is available
   3155              if ( ZDSecMgrEntries != NULL )
   3156              {
   3157                // find available entry
   3158                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3159                {
   3160                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3161                  {
   3162                    // return successful result
   3163                    entry = &ZDSecMgrEntries[index];
   3164          
   3165                    // get NWK address
   3166                    addrEntry.index = entry->ami;
   3167          
   3168                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3169                    {
   3170                      req.dstAddr = addrEntry.nwkAddr;
   3171                      status = APSME_SwitchKeyReq( &req );
   3172                    }
   3173                  }
   3174                }
   3175              }
   3176            }
   3177            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3178            {
   3179              status = APSME_SwitchKeyReq( &req );
   3180            }
   3181          
   3182            SSP_SwitchNwkKey( keySeqNum );
   3183          
   3184            // Save if nv
   3185            ZDApp_NVUpdate();
   3186          
   3187            return status;
   3188          }
   3189          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3190          
   3191          #if ( ZG_BUILD_JOINING_TYPE )
   3192          /******************************************************************************
   3193           * @fn          ZDSecMgrRequestAppKey
   3194           *
   3195           * @brief       Request an application key with partner.
   3196           *
   3197           * @param       partNwkAddr - [in] partner network address
   3198           *
   3199           * @return      ZStatus_t
   3200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3201          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   \                     ZDSecMgrRequestAppKey:
   3202          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 12
   \   000004   74F4         MOV     A,#-0xc
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   3203            ZStatus_t             status;
   3204            APSME_RequestKeyReq_t req;
   3205            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3206          
   3207          
   3208            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   \   000009                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000009   7404         MOV     A,#0x4
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   AC82         MOV     R4,DPL
   \   000010   AD83         MOV     R5,DPH
   \   000012   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000015   E9           MOV     A,R1
   \   000016   6031         JZ      ??ZDSecMgrRequestAppKey_0
   3209            {
   3210              req.dstAddr = 0;
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   E4           CLR     A
   \   00001F   F0           MOVX    @DPTR,A
   3211              req.keyType = KEY_TYPE_APP_MASTER;
   \   000020   04           INC     A
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
   3212              req.partExtAddr = partExtAddr;
   \   000027   7404         MOV     A,#0x4
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   A882         MOV     R0,DPL
   \   00002E   A983         MOV     R1,DPH
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E8           MOV     A,R0
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   E9           MOV     A,R1
   \   000039   F0           MOVX    @DPTR,A
   3213              status = APSME_RequestKeyReq( &req );
   \   00003A                ; Setup parameters for call to function APSME_RequestKeyReq
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   AA82         MOV     R2,DPL
   \   000042   AB83         MOV     R3,DPH
   \   000044   12....       LCALL   ??APSME_RequestKeyReq?relay
   \   000047   8002         SJMP    ??ZDSecMgrRequestAppKey_1
   3214            }
   3215            else
   3216            {
   3217              status = ZFailure;
   \                     ??ZDSecMgrRequestAppKey_0:
   \   000049   7901         MOV     R1,#0x1
   3218            }
   3219          
   3220            return status;
   \                     ??ZDSecMgrRequestAppKey_1:
   \   00004B   740C         MOV     A,#0xc
   \   00004D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000050   D083         POP     DPH
   \   000052   D082         POP     DPL
   \   000054   02....       LJMP    ?BRET
   3221          }
   3222          #endif // ( ZG_BUILD_JOINING_TYPE )
   3223          
   3224          #if ( ZG_BUILD_JOINING_TYPE )
   3225          /******************************************************************************
   3226           * @fn          ZDSecMgrSetupPartner
   3227           *
   3228           * @brief       Setup for application key partner.
   3229           *
   3230           * @param       partNwkAddr - [in] partner network address
   3231           *
   3232           * @return      ZStatus_t
   3233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3234          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3235          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   3236            AddrMgrEntry_t entry;
   3237            ZStatus_t      status;
   3238          
   3239            status = ZFailure;
   \   000012   75..01       MOV     ?V0 + 2,#0x1
   3240          
   3241            // update the address manager
   3242            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7402         MOV     A,#0x2
   \   00001D   F0           MOVX    @DPTR,A
   3243            entry.nwkAddr = partNwkAddr;
   \   00001E   14           DEC     A
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
   3244            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \   000027                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000027   7403         MOV     A,#0x3
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   AA82         MOV     R2,DPL
   \   00002E   AB83         MOV     R3,DPH
   \   000030   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3245          
   3246            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000033                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   AA82         MOV     R2,DPL
   \   00003B   AB83         MOV     R3,DPH
   \   00003D   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000040   E9           MOV     A,R1
   \   000041   6401         XRL     A,#0x1
   \   000043   7036         JNZ     ??ZDSecMgrSetupPartner_0
   3247            {
   3248              status = ZSuccess;
   \   000045   75..00       MOV     ?V0 + 2,#0x0
   3249          
   3250              // check for address discovery
   3251              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000048   74FE         MOV     A,#-0x2
   \   00004A   6E           XRL     A,R6
   \   00004B   7003         JNZ     ??ZDSecMgrSetupPartner_1
   \   00004D   74FF         MOV     A,#-0x1
   \   00004F   6F           XRL     A,R7
   \                     ??ZDSecMgrSetupPartner_1:
   \   000050   700F         JNZ     ??ZDSecMgrSetupPartner_2
   3252              {
   3253                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000052                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   000052   7D00         MOV     R5,#0x0
   \   000054   7C00         MOV     R4,#0x0
   \   000056   7900         MOV     R1,#0x0
   \   000058   AA..         MOV     R2,?V0 + 0
   \   00005A   AB..         MOV     R3,?V0 + 1
   \   00005C   12....       LCALL   ??ZDP_NwkAddrReq?relay
   \   00005F   8017         SJMP    ??ZDSecMgrSetupPartner_3
   3254              }
   3255              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   000061                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000061   AA..         MOV     R2,?V0 + 0
   \   000063   AB..         MOV     R3,?V0 + 1
   \   000065   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000068   E9           MOV     A,R1
   \   000069   7010         JNZ     ??ZDSecMgrSetupPartner_0
   3256              {
   3257                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00006B                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   00006B   7D00         MOV     R5,#0x0
   \   00006D   7C00         MOV     R4,#0x0
   \   00006F   7900         MOV     R1,#0x0
   \   000071   EE           MOV     A,R6
   \   000072   FA           MOV     R2,A
   \   000073   EF           MOV     A,R7
   \   000074   FB           MOV     R3,A
   \   000075   12....       LCALL   ??ZDP_IEEEAddrReq?relay
   \                     ??ZDSecMgrSetupPartner_3:
   \   000078   E9           MOV     A,R1
   \   000079   F5..         MOV     ?V0 + 2,A
   3258              }
   3259            }
   3260          
   3261            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   00007B   A9..         MOV     R1,?V0 + 2
   \   00007D   740D         MOV     A,#0xd
   \   00007F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000082   7F03         MOV     R7,#0x3
   \   000084   02....       LJMP    ?BANKED_LEAVE_XDATA
   3262          }
   3263          #endif // ( ZG_BUILD_JOINING_TYPE )
   3264          
   3265          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3266          /******************************************************************************
   3267           * @fn          ZDSecMgrAppKeyTypeSet
   3268           *
   3269           * @brief       Set application key type.
   3270           *
   3271           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3272           *                                                   KEY_TYPE_APP_LINK@3
   3273           *
   3274           * @return      ZStatus_t
   3275           */
   3276          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3277          {
   3278            if ( keyType == KEY_TYPE_APP_LINK )
   3279            {
   3280              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3281            }
   3282            else
   3283            {
   3284              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3285            }
   3286          
   3287            return ZSuccess;
   3288          }
   3289          #endif
   3290          
   3291          /******************************************************************************
   3292           * ZigBee Device Security Manager - Stub Implementations
   3293           */
   3294          /******************************************************************************
   3295           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3296           *
   3297           * @brief       Get MASTER key for specified EXT address.
   3298           *
   3299           * @param       extAddr - [in] EXT address
   3300           * @param       key     - [out] MASTER key
   3301           *
   3302           * @return      ZStatus_t
   3303           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3304          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint8** key )
   \                     APSME_MasterKeyGet:
   3305          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3306            ZStatus_t status;
   3307            uint16    ami;
   3308          
   3309          
   3310            // lookup entry for specified EXT address
   3311            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   3312            //status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3313          
   3314            if ( status == ZSuccess )
   \   00001E   7014         JNZ     ??APSME_MasterKeyGet_0
   3315            {
   3316              ZDSecMgrMasterKeyLookup( ami, key );
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   EE           MOV     A,R6
   \   000021   FC           MOV     R4,A
   \   000022   EF           MOV     A,R7
   \   000023   FD           MOV     R5,A
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   FA           MOV     R2,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FB           MOV     R3,A
   \   00002F   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000032   8008         SJMP    ??APSME_MasterKeyGet_1
   3317            }
   3318            else
   3319            {
   3320              *key = NULL;
   \                     ??APSME_MasterKeyGet_0:
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   E4           CLR     A
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   F0           MOVX    @DPTR,A
   3321            }
   3322          
   3323            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   00003C   A9..         MOV     R1,?V0 + 0
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?DEALLOC_XSTACK8
   \   000043   7F01         MOV     R7,#0x1
   \   000045   02....       LJMP    ?BANKED_LEAVE_XDATA
   3324          }
   3325          
   3326          /******************************************************************************
   3327           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3328           *
   3329           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3330           *
   3331           * @param       extAddr - [in] EXT address
   3332           * @param       data    - [in] APSME_LinkKeyData_t
   3333           *
   3334           * @return      ZStatus_t
   3335           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3336          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3337          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 0,R4
   \   00000C   8D..         MOV     ?V0 + 1,R5
   3338            ZStatus_t        status;
   3339            ZDSecMgrEntry_t* entry;
   3340          
   3341          
   3342            // lookup entry index for specified EXT address
   3343            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   FE           MOV     R6,A
   3344          
   3345            if ( status == ZSuccess )
   \   00001D   705A         JNZ     ??APSME_LinkKeySet_0
   3346            {
   3347              // setup the link key data reference
   3348              osal_memcpy( entry->lkd.key, key, SEC_KEY_LEN );
   \   00001F                ; Setup parameters for call to function osal_memcpy
   \   00001F   75..00       MOV     ?V0 + 2,#0x0
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000027   7C10         MOV     R4,#0x10
   \   000029   7D00         MOV     R5,#0x0
   \   00002B   7403         MOV     A,#0x3
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E0           MOVX    A,@DPTR
   \   000031   2402         ADD     A,#0x2
   \   000033   FA           MOV     R2,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   3400         ADDC    A,#0x0
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??osal_memcpy?relay
   \   00003C   7403         MOV     A,#0x3
   \   00003E   12....       LCALL   ?DEALLOC_XSTACK8
   3349          
   3350              entry->lkd.apsmelkd.rxFrmCntr = 0;
   \   000041   90....       MOV     DPTR,#__Constant_0
   \   000044   12....       LCALL   ?XLOAD_R2345
   \   000047   85..82       MOV     DPL,?XSP + 0
   \   00004A   85..83       MOV     DPH,?XSP + 1
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   2418         ADD     A,#0x18
   \   000050   F8           MOV     R0,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   3400         ADDC    A,#0x0
   \   000055   F9           MOV     R1,A
   \   000056   8882         MOV     DPL,R0
   \   000058   8983         MOV     DPH,R1
   \   00005A   12....       LCALL   ?XSTORE_R2345
   3351              entry->lkd.apsmelkd.txFrmCntr = 0;
   \   00005D   90....       MOV     DPTR,#__Constant_0
   \   000060   12....       LCALL   ?XLOAD_R2345
   \   000063   85..82       MOV     DPL,?XSP + 0
   \   000066   85..83       MOV     DPH,?XSP + 1
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   2414         ADD     A,#0x14
   \   00006C   F8           MOV     R0,A
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   3400         ADDC    A,#0x0
   \   000071   F9           MOV     R1,A
   \   000072   8882         MOV     DPL,R0
   \   000074   8983         MOV     DPH,R1
   \   000076   12....       LCALL   ?XSTORE_R2345
   3352            }
   3353          
   3354            return status;
   \                     ??APSME_LinkKeySet_0:
   \   000079   EE           MOV     A,R6
   \   00007A   F9           MOV     R1,A
   \   00007B   7402         MOV     A,#0x2
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000080   7F03         MOV     R7,#0x3
   \   000082   02....       LJMP    ?BANKED_LEAVE_XDATA
   3355          }
   3356          
   3357          /******************************************************************************
   3358           * @fn          ZDSecMgrAuthenticationSet
   3359           *
   3360           * @brief       Mark the specific device as authenticated or not
   3361           *
   3362           * @param       extAddr - [in] EXT address
   3363           * @param       option  - [in] authenticated or not
   3364           *
   3365           * @return      ZStatus_t
   3366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3367          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3368          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   3369            ZStatus_t        status;
   3370            ZDSecMgrEntry_t* entry;
   3371          
   3372          
   3373            // lookup entry index for specified EXT address
   3374            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   AC82         MOV     R4,DPL
   \   000014   AD83         MOV     R5,DPH
   \   000016   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000019   E9           MOV     A,R1
   3375          
   3376            if ( status == ZSuccess )
   \   00001A   7019         JNZ     ??ZDSecMgrAuthenticationSet_0
   3377            {
   3378              entry->authenticateOption = option;
   \   00001C   EE           MOV     A,R6
   \   00001D   C0E0         PUSH    A
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   E0           MOVX    A,@DPTR
   \   000026   241C         ADD     A,#0x1c
   \   000028   FA           MOV     R2,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   3400         ADDC    A,#0x0
   \   00002D   FB           MOV     R3,A
   \   00002E   8A82         MOV     DPL,R2
   \   000030   8B83         MOV     DPH,R3
   \   000032   D0E0         POP     A
   \   000034   F0           MOVX    @DPTR,A
   3379            }
   3380          
   3381            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000035   7402         MOV     A,#0x2
   \   000037   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003A   7F01         MOV     R7,#0x1
   \   00003C   02....       LJMP    ?BANKED_LEAVE_XDATA
   3382          }
   3383          
   3384          /******************************************************************************
   3385           * @fn          ZDSecMgrAuthenticationCheck
   3386           *
   3387           * @brief       Check if the specific device has been authenticated or not
   3388           *              For non-trust center device, always return true
   3389           *
   3390           * @param       shortAddr - [in] short address
   3391           *
   3392           * @return      TRUE @ authenticated with CBKE
   3393           *              FALSE @ not authenticated
   3394           */
   3395          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3396          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3397          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3398          #if defined (SE_PROFILE)
   3399          
   3400            ZDSecMgrEntry_t* entry;
   3401            uint8 extAddr[Z_EXTADDR_LEN];
   3402          
   3403            // If the local device is not the trust center, always return TRUE
   3404            if ( NLME_GetShortAddr() != TCshortAddr )
   3405            {
   3406              return TRUE;
   3407            }
   3408            // Otherwise, check the authentication option
   3409            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3410            {
   3411              // lookup entry index for specified EXT address
   3412              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3413              {
   3414                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3415                {
   3416                  return TRUE;
   3417                }
   3418                else
   3419                {
   3420                  return FALSE;
   3421                }
   3422              }
   3423            }
   3424            return FALSE;
   3425          
   3426          #else
   3427            (void)shortAddr;  // Intentionally unreferenced parameter
   3428            
   3429            // For non AMI/SE Profile, perform no check and always return true.
   3430            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3431          
   3432          #endif // SE_PROFILE
   3433          }
   3434          
   3435          
   3436          /******************************************************************************
   3437           * @fn          ZDSecMgrLinkKeyDataGet (stubs APSME_LinkKeyDataGet)
   3438           *
   3439           * @brief       Get <APSME_LinkKeyData_t> for specified NWK address.
   3440           *
   3441           * @param       extAddr - [in] EXT address
   3442           * @param       data    - [out] APSME_LinkKeyData_t
   3443           *
   3444           * @return      ZStatus_t
   3445           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3446          ZStatus_t ZDSecMgrLinkKeyDataGet(uint8* extAddr, APSME_LinkKeyData_t** data)
   \                     APSME_LinkKeyDataGet:
   3447          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3448            ZStatus_t        status;
   3449            ZDSecMgrEntry_t* entry;
   3450          
   3451          
   3452            // lookup entry index for specified NWK address
   3453            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   3454          
   3455            if ( status == ZSuccess )
   \   00001C   7039         JNZ     ??APSME_LinkKeyDataGet_0
   3456            {
   3457              // setup the link key data reference
   3458              (*data) = &entry->lkd.apsmelkd;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   2412         ADD     A,#0x12
   \   000027   FA           MOV     R2,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   3400         ADDC    A,#0x0
   \   00002C   FB           MOV     R3,A
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   EA           MOV     A,R2
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   EB           MOV     A,R3
   \   000035   F0           MOVX    @DPTR,A
   3459              (*data)->key = entry->lkd.key;
   \   000036   85..82       MOV     DPL,?XSP + 0
   \   000039   85..83       MOV     DPH,?XSP + 1
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   2402         ADD     A,#0x2
   \   00003F   FA           MOV     R2,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   3400         ADDC    A,#0x0
   \   000044   FB           MOV     R3,A
   \   000045   8E82         MOV     DPL,R6
   \   000047   8F83         MOV     DPH,R7
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F8           MOV     R0,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F583         MOV     DPH,A
   \   00004F   8882         MOV     DPL,R0
   \   000051   EA           MOV     A,R2
   \   000052   F0           MOVX    @DPTR,A
   \   000053   A3           INC     DPTR
   \   000054   EB           MOV     A,R3
   \   000055   8007         SJMP    ??APSME_LinkKeyDataGet_1
   3460            }
   3461            else
   3462            {
   3463              *data = NULL;
   \                     ??APSME_LinkKeyDataGet_0:
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \                     ??APSME_LinkKeyDataGet_1:
   \   00005E   F0           MOVX    @DPTR,A
   3464            }
   3465          
   3466            return status;
   \   00005F   7402         MOV     A,#0x2
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   \   000064   7F01         MOV     R7,#0x1
   \   000066   02....       LJMP    ?BANKED_LEAVE_XDATA
   3467          }
   3468          
   3469          /******************************************************************************
   3470           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3471           *
   3472           * @brief       Verify and process key transportation to child.
   3473           *
   3474           * @param       ind - [in] APSME_TransportKeyInd_t
   3475           *
   3476           * @return      uint8 - success(TRUE:FALSE)
   3477           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3478          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3479          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3480            uint8 success;
   3481          
   3482            success = FALSE;
   \   000005   7E00         MOV     R6,#0x0
   3483          
   3484            // verify from Trust Center
   3485            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F8           MOV     R0,A
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F9           MOV     R1,A
   \   000010   E8           MOV     A,R0
   \   000011   49           ORL     A,R1
   \   000012   702F         JNZ     ??APSME_KeyFwdToChild_0
   3486            {
   3487              success = TRUE;
   \   000014   0E           INC     R6
   3488          
   3489              // check for initial NWK key
   3490              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3491                   ( ind->keyType == 6                 ) ||
   3492                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000015   EA           MOV     A,R2
   \   000016   2402         ADD     A,#0x2
   \   000018   F582         MOV     DPL,A
   \   00001A   EB           MOV     A,R3
   \   00001B   3400         ADDC    A,#0x0
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6401         XRL     A,#0x1
   \   000022   600A         JZ      ??APSME_KeyFwdToChild_1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6406         XRL     A,#0x6
   \   000027   6005         JZ      ??APSME_KeyFwdToChild_1
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6405         XRL     A,#0x5
   \   00002C   7015         JNZ     ??APSME_KeyFwdToChild_0
   3493              {
   3494                // set association status to authenticated
   3495                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   00002E                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002E                ; Setup parameters for call to function AssocGetWithExt
   \   00002E   8A82         MOV     DPL,R2
   \   000030   8B83         MOV     DPH,R3
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??AssocGetWithExt?relay
   \   000040   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   3496              }
   3497            }
   3498          
   3499            return success;
   \                     ??APSME_KeyFwdToChild_0:
   \   000043   EE           MOV     A,R6
   \   000044   F9           MOV     R1,A
   \   000045   7F01         MOV     R7,#0x1
   \   000047   02....       LJMP    ?BANKED_LEAVE_XDATA
   3500          }
   3501          
   3502          /******************************************************************************
   3503           * @fn          ZDSecMgrAddLinkKey
   3504           *
   3505           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3506           *              as authenticated in the authenticateOption. Note that this function
   3507           *              is hardwared to CBKE right now.
   3508           *
   3509           * @param       shortAddr - short address of the partner device
   3510           * @param       extAddr - extended address of the partner device
   3511           * @param       key - link key
   3512           *
   3513           * @return      none
   3514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3515          void ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3516          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   7410         MOV     A,#0x10
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
   3517            uint16           ami;
   3518            ZDSecMgrEntry_t* entry;
   3519          
   3520            ZDSecMgrAddrStore( shortAddr, extAddr, &ami );
   \   00001A                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   8582..       MOV     ?V0 + 2,DPL
   \   000022   8583..       MOV     ?V0 + 3,DPH
   \   000025   78..         MOV     R0,#?V0 + 2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   3521          
   3522            ZDSecMgrEntryLookupAMI( ami, &entry );
   \   000032                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   AC82         MOV     R4,DPL
   \   00003A   AD83         MOV     R5,DPH
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E0           MOVX    A,@DPTR
   \   000042   FA           MOV     R2,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   FB           MOV     R3,A
   \   000046   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   3523          
   3524            // If no existing entry, create one
   3525            if ( entry == NULL )
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F8           MOV     R0,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F9           MOV     R1,A
   \   000054   E8           MOV     A,R0
   \   000055   49           ORL     A,R1
   \   000056   702D         JNZ     ??ZDSecMgrAddLinkKey_0
   3526            {
   3527              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000058                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   AA82         MOV     R2,DPL
   \   000060   AB83         MOV     R3,DPH
   \   000062   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000065   E9           MOV     A,R1
   \   000066   701D         JNZ     ??ZDSecMgrAddLinkKey_0
   3528              {
   3529                entry->ami = ami;
   \   000068   7402         MOV     A,#0x2
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F8           MOV     R0,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   F9           MOV     R1,A
   \   000072   85..82       MOV     DPL,?XSP + 0
   \   000075   85..83       MOV     DPH,?XSP + 1
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F583         MOV     DPH,A
   \   00007E   8A82         MOV     DPL,R2
   \   000080   E8           MOV     A,R0
   \   000081   F0           MOVX    @DPTR,A
   \   000082   A3           INC     DPTR
   \   000083   E9           MOV     A,R1
   \   000084   F0           MOVX    @DPTR,A
   3530              }
   3531            }
   3532            // Write the link key
   3533            APSME_LinkKeySet( extAddr, key );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000085                ; Setup parameters for call to function APSME_LinkKeySet
   \   000085   AC..         MOV     R4,?V0 + 0
   \   000087   AD..         MOV     R5,?V0 + 1
   \   000089   EE           MOV     A,R6
   \   00008A   FA           MOV     R2,A
   \   00008B   EF           MOV     A,R7
   \   00008C   FB           MOV     R3,A
   \   00008D   12....       LCALL   ??APSME_LinkKeySet?relay
   3534          
   3535          #if defined (SE_PROFILE)
   3536            // Mark the device as authenticated.
   3537            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3538          #endif
   3539          
   3540            // Write the new established link key to NV.
   3541            ZDSecMgrWriteNV();
   \   000090                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   000090   12....       LCALL   ??ZDSecMgrWriteNV?relay
   3542          }
   \   000093   7404         MOV     A,#0x4
   \   000095   12....       LCALL   ?DEALLOC_XSTACK8
   \   000098   7F04         MOV     R7,#0x4
   \   00009A   02....       LJMP    ?BANKED_LEAVE_XDATA
   3543          
   3544          /******************************************************************************
   3545           * @fn          ZDSecMgrInitNV
   3546           *
   3547           * @brief       Initialize the SecMgr entry data in NV.
   3548           *
   3549           * @param       none
   3550           *
   3551           * @return      uint8 - <osal_nv_item_init> return codes
   3552           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3553          uint8 ZDSecMgrInitNV( void )
   \                     ZDSecMgrInitNV:
   3554          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3555            uint8  status;
   3556            uint16 size;
   3557          
   3558            size = (uint16)( sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX );
   3559          
   3560            status = osal_nv_item_init( ZCD_NV_APS_LINK_KEY_TABLE, size, NULL );
   \   000005                ; Setup parameters for call to function osal_nv_item_init
   \   000005   E4           CLR     A
   \   000006   F5..         MOV     ?V0 + 0,A
   \   000008   F5..         MOV     ?V0 + 1,A
   \   00000A   78..         MOV     R0,#?V0 + 0
   \   00000C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000F   7C57         MOV     R4,#0x57
   \   000011   7D00         MOV     R5,#0x0
   \   000013   7A4C         MOV     R2,#0x4c
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   ??osal_nv_item_init?relay
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001F   E9           MOV     A,R1
   \   000020   FE           MOV     R6,A
   3561          
   3562            // The item does not already exist
   3563            if ( status != ZSUCCESS )
   \   000021   6003         JZ      ??ZDSecMgrInitNV_0
   3564            {
   3565              ZDSecMgrSetDefaultNV();
   \   000023                ; Setup parameters for call to function ZDSecMgrSetDefaultNV
   \   000023   12....       LCALL   ??ZDSecMgrSetDefaultNV?relay
   3566            }
   3567          
   3568            return status;
   \                     ??ZDSecMgrInitNV_0:
   \   000026   EE           MOV     A,R6
   \   000027   F9           MOV     R1,A
   \   000028   7F02         MOV     R7,#0x2
   \   00002A   02....       LJMP    ?BANKED_LEAVE_XDATA
   3569          }
   3570          
   3571          
   3572          /******************************************************************************
   3573           * @fn          ZDSecMgrSetDefaultNV
   3574           *
   3575           * @brief       Set default SecMgr entry data in NV.
   3576           *
   3577           * @param       none
   3578           *
   3579           * @return      none
   3580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3581          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3582          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3583            nvDeviceListHdr_t hdr;
   3584          
   3585            // Initialize the header
   3586            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
   3587          
   3588            // Save off the header
   3589            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \   000014                ; Setup parameters for call to function osal_nv_write
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   8582..       MOV     ?V0 + 0,DPL
   \   00001D   8583..       MOV     ?V0 + 1,DPH
   \   000020   78..         MOV     R0,#?V0 + 0
   \   000022   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000025   75..02       MOV     ?V0 + 0,#0x2
   \   000028   75..00       MOV     ?V0 + 1,#0x0
   \   00002B   78..         MOV     R0,#?V0 + 0
   \   00002D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000030   7C00         MOV     R4,#0x0
   \   000032   7D00         MOV     R5,#0x0
   \   000034   7A4C         MOV     R2,#0x4c
   \   000036   7B00         MOV     R3,#0x0
   \   000038   12....       LCALL   ??osal_nv_write?relay
   \   00003B   7404         MOV     A,#0x4
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   3590          }
   \   000040   7402         MOV     A,#0x2
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
   \   000045   7F02         MOV     R7,#0x2
   \   000047   02....       LJMP    ?BANKED_LEAVE_XDATA
   3591          
   3592          
   3593          
   3594          /*********************************************************************
   3595           * @fn      ZDSecMgrWriteNV()
   3596           *
   3597           * @brief   Save off the link key list to NV
   3598           *
   3599           * @param   none
   3600           *
   3601           * @return  none
   3602           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3603          void ZDSecMgrWriteNV( void )
   \                     ZDSecMgrWriteNV:
   3604          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3605            uint16 i;
   3606            nvDeviceListHdr_t hdr;
   3607          
   3608            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
   3609          
   3610            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000014   FE           MOV     R6,A
   \   000015   02....       LJMP    ??ZDSecMgrWriteNV_0 & 0xFFFF
   3611            {
   3612              if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   \                     ??ZDSecMgrWriteNV_1:
   \   000018   EE           MOV     A,R6
   \   000019   F8           MOV     R0,A
   \   00001A   EF           MOV     A,R7
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   75F01D       MOV     B,#0x1d
   \   000020   A4           MUL     AB
   \   000021   F8           MOV     R0,A
   \   000022   AAF0         MOV     R2,B
   \   000024   75F01D       MOV     B,#0x1d
   \   000027   E9           MOV     A,R1
   \   000028   A4           MUL     AB
   \   000029   2A           ADD     A,R2
   \   00002A   F9           MOV     R1,A
   \   00002B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   28           ADD     A,R0
   \   000030   F5..         MOV     ?V0 + 0,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   39           ADDC    A,R1
   \   000035   F5..         MOV     ?V0 + 1,A
   \   000037   85..82       MOV     DPL,?V0 + 0
   \   00003A   F583         MOV     DPH,A
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   64FE         XRL     A,#0xfe
   \   00003F   7003         JNZ     ??ZDSecMgrWriteNV_2
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F4           CPL     A
   \                     ??ZDSecMgrWriteNV_2:
   \   000044   604C         JZ      ??ZDSecMgrWriteNV_3
   3613              {
   3614                // Save off the record
   3615                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3616                        (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3617                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   \   000046                ; Setup parameters for call to function osal_nv_write
   \   000046   78..         MOV     R0,#?V0 + 0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   75..1D       MOV     ?V0 + 0,#0x1d
   \   00004E   75..00       MOV     ?V0 + 1,#0x0
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000056   7404         MOV     A,#0x4
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F8           MOV     R0,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   E8           MOV     A,R0
   \   000061   75F01D       MOV     B,#0x1d
   \   000064   A4           MUL     AB
   \   000065   F8           MOV     R0,A
   \   000066   AAF0         MOV     R2,B
   \   000068   75F01D       MOV     B,#0x1d
   \   00006B   E9           MOV     A,R1
   \   00006C   A4           MUL     AB
   \   00006D   2A           ADD     A,R2
   \   00006E   F9           MOV     R1,A
   \   00006F   E8           MOV     A,R0
   \   000070   2402         ADD     A,#0x2
   \   000072   FC           MOV     R4,A
   \   000073   E9           MOV     A,R1
   \   000074   3400         ADDC    A,#0x0
   \   000076   FD           MOV     R5,A
   \   000077   7A4C         MOV     R2,#0x4c
   \   000079   7B00         MOV     R3,#0x0
   \   00007B   12....       LCALL   ??osal_nv_write?relay
   \   00007E   7404         MOV     A,#0x4
   \   000080   12....       LCALL   ?DEALLOC_XSTACK8
   3618                hdr.numRecs++;
   \   000083   85..82       MOV     DPL,?XSP + 0
   \   000086   85..83       MOV     DPH,?XSP + 1
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   2401         ADD     A,#0x1
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   A3           INC     DPTR
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   3400         ADDC    A,#0x0
   \   000091   F0           MOVX    @DPTR,A
   3619              }
   3620            }
   \                     ??ZDSecMgrWriteNV_3:
   \   000092   EE           MOV     A,R6
   \   000093   2401         ADD     A,#0x1
   \   000095   0E           INC     R6
   \   000096   EF           MOV     A,R7
   \   000097   3400         ADDC    A,#0x0
   \                     ??ZDSecMgrWriteNV_0:
   \   000099   FF           MOV     R7,A
   \   00009A   C3           CLR     C
   \   00009B   EE           MOV     A,R6
   \   00009C   9403         SUBB    A,#0x3
   \   00009E   EF           MOV     A,R7
   \   00009F   9400         SUBB    A,#0x0
   \   0000A1   5003         JNC     $+5
   \   0000A3   02....       LJMP    ??ZDSecMgrWriteNV_1 & 0xFFFF
   3621          
   3622            // Save off the header
   3623            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \   0000A6                ; Setup parameters for call to function osal_nv_write
   \   0000A6   85..82       MOV     DPL,?XSP + 0
   \   0000A9   85..83       MOV     DPH,?XSP + 1
   \   0000AC   8582..       MOV     ?V0 + 0,DPL
   \   0000AF   8583..       MOV     ?V0 + 1,DPH
   \   0000B2   78..         MOV     R0,#?V0 + 0
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B7   75..02       MOV     ?V0 + 0,#0x2
   \   0000BA   75..00       MOV     ?V0 + 1,#0x0
   \   0000BD   78..         MOV     R0,#?V0 + 0
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C2   7C00         MOV     R4,#0x0
   \   0000C4   7D00         MOV     R5,#0x0
   \   0000C6   7A4C         MOV     R2,#0x4c
   \   0000C8   7B00         MOV     R3,#0x0
   \   0000CA   12....       LCALL   ??osal_nv_write?relay
   \   0000CD   7404         MOV     A,#0x4
   \   0000CF   12....       LCALL   ?DEALLOC_XSTACK8
   3624          }
   \   0000D2   7402         MOV     A,#0x2
   \   0000D4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D7   7F02         MOV     R7,#0x2
   \   0000D9   02....       LJMP    ?BANKED_LEAVE_XDATA
   3625          
   3626          /******************************************************************************
   3627           * @fn          ZDSecMgrRestoreFromNV
   3628           *
   3629           * @brief       Restore the SecMgr entry data from NV.
   3630           *
   3631           * @param       none
   3632           *
   3633           * @return      ZStatus_t ZSuccess or ZFailure
   3634           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3635          ZStatus_t ZDSecMgrRestoreFromNV( void )
   \                     ZDSecMgrRestoreFromNV:
   3636          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3637            uint8 x = 0;
   \   00000A   75..00       MOV     ?V0 + 4,#0x0
   3638            nvDeviceListHdr_t hdr;
   3639          
   3640            // Initialize the device list
   3641            if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr ) == ZSUCCESS )
   \   00000D                ; Setup parameters for call to function osal_nv_read
   \   00000D   85..82       MOV     DPL,?XSP + 0
   \   000010   85..83       MOV     DPH,?XSP + 1
   \   000013   8582..       MOV     ?V0 + 0,DPL
   \   000016   8583..       MOV     ?V0 + 1,DPH
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001E   75..02       MOV     ?V0 + 0,#0x2
   \   000021   75..00       MOV     ?V0 + 1,#0x0
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   7C00         MOV     R4,#0x0
   \   00002B   7D00         MOV     R5,#0x0
   \   00002D   7A4C         MOV     R2,#0x4c
   \   00002F   7B00         MOV     R3,#0x0
   \   000031   12....       LCALL   ??osal_nv_read?relay
   \   000034   7404         MOV     A,#0x4
   \   000036   12....       LCALL   ?DEALLOC_XSTACK8
   \   000039   E9           MOV     A,R1
   \   00003A   606F         JZ      ??ZDSecMgrRestoreFromNV_0
   3642            {
   3643              // Read in the device list
   3644              for ( ; x < hdr.numRecs; x++ )
   3645              {
   3646                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3647                          (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3648                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == ZSUCCESS )
   3649                {
   3650                  ZDSecMgrEntries[x].lkd.apsmelkd.txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3651                }
   3652              }
   3653          
   3654              // Write the updated entry back to NV.
   3655              ZDSecMgrWriteNV();
   3656          
   3657              return ZSuccess;
   3658            }
   3659            return ZFailure;
   \   00003C   7901         MOV     R1,#0x1
   \                     ??ZDSecMgrRestoreFromNV_1:
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?DEALLOC_XSTACK8
   \   000043   7F05         MOV     R7,#0x5
   \   000045   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??ZDSecMgrRestoreFromNV_2:
   \   000048   EA           MOV     A,R2
   \   000049   75F01D       MOV     B,#0x1d
   \   00004C   A4           MUL     AB
   \   00004D   FE           MOV     R6,A
   \   00004E   AFF0         MOV     R7,B
   \   000050                ; Setup parameters for call to function osal_nv_read
   \   000050   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000053   E0           MOVX    A,@DPTR
   \   000054   2E           ADD     A,R6
   \   000055   F5..         MOV     ?V0 + 0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   3F           ADDC    A,R7
   \   00005A   F5..         MOV     ?V0 + 1,A
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000061   75..1D       MOV     ?V0 + 0,#0x1d
   \   000064   75..00       MOV     ?V0 + 1,#0x0
   \   000067   78..         MOV     R0,#?V0 + 0
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   EA           MOV     A,R2
   \   00006D   75F01D       MOV     B,#0x1d
   \   000070   A4           MUL     AB
   \   000071   2402         ADD     A,#0x2
   \   000073   FC           MOV     R4,A
   \   000074   E5F0         MOV     A,B
   \   000076   3400         ADDC    A,#0x0
   \   000078   FD           MOV     R5,A
   \   000079   7A4C         MOV     R2,#0x4c
   \   00007B   7B00         MOV     R3,#0x0
   \   00007D   12....       LCALL   ??osal_nv_read?relay
   \   000080   7404         MOV     A,#0x4
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   E9           MOV     A,R1
   \   000086   7021         JNZ     ??ZDSecMgrRestoreFromNV_3
   \   000088   90....       MOV     DPTR,#__Constant_b
   \   00008B   78..         MOV     R0,#?V0 + 0
   \   00008D   12....       LCALL   ?L_MOV_X
   \   000090   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000093   E0           MOVX    A,@DPTR
   \   000094   2E           ADD     A,R6
   \   000095   F8           MOV     R0,A
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   3F           ADDC    A,R7
   \   000099   F9           MOV     R1,A
   \   00009A   E8           MOV     A,R0
   \   00009B   2414         ADD     A,#0x14
   \   00009D   F582         MOV     DPL,A
   \   00009F   E9           MOV     A,R1
   \   0000A0   3400         ADDC    A,#0x0
   \   0000A2   F583         MOV     DPH,A
   \   0000A4   78..         MOV     R0,#?V0 + 0
   \   0000A6   12....       LCALL   ?L_ADD_TO_X
   \                     ??ZDSecMgrRestoreFromNV_3:
   \   0000A9   05..         INC     ?V0 + 4
   \                     ??ZDSecMgrRestoreFromNV_0:
   \   0000AB   85..82       MOV     DPL,?V0 + 4
   \   0000AE   AA82         MOV     R2,DPL
   \   0000B0   85..82       MOV     DPL,?XSP + 0
   \   0000B3   85..83       MOV     DPH,?XSP + 1
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   F8           MOV     R0,A
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   F9           MOV     R1,A
   \   0000BB   C3           CLR     C
   \   0000BC   EA           MOV     A,R2
   \   0000BD   98           SUBB    A,R0
   \   0000BE   E4           CLR     A
   \   0000BF   99           SUBB    A,R1
   \   0000C0   4086         JC      ??ZDSecMgrRestoreFromNV_2
   \   0000C2                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   0000C2   12....       LCALL   ??ZDSecMgrWriteNV?relay
   \   0000C5   7900         MOV     R1,#0x0
   \   0000C7   02....       LJMP    ??ZDSecMgrRestoreFromNV_1 & 0xFFFF
   3660          }
   3661          
   3662          /******************************************************************************
   3663           * @fn          ZDSecMgrAPSRemove
   3664           *
   3665           * @brief       Remove device from network.
   3666           *
   3667           * @param       nwkAddr - device's NWK address
   3668           * @param       extAddr - device's Extended address
   3669           * @param       parentAddr - parent's NWK address
   3670           *
   3671           * @return      ZStatus_t
   3672           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3673          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3674          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   \   000009   740A         MOV     A,#0xa
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   3675            ZDSecMgrDevice_t device;
   3676          
   3677            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3678                 ( extAddr == NULL )              ||
   3679                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000013   74FE         MOV     A,#-0x2
   \   000015   6A           XRL     A,R2
   \   000016   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   000018   74FF         MOV     A,#-0x1
   \   00001A   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   00001B   600E         JZ      ??ZDSecMgrAPSRemove_1
   \   00001D   EC           MOV     A,R4
   \   00001E   4D           ORL     A,R5
   \   00001F   600A         JZ      ??ZDSecMgrAPSRemove_1
   \   000021   74FE         MOV     A,#-0x2
   \   000023   68           XRL     A,R0
   \   000024   7003         JNZ     ??ZDSecMgrAPSRemove_2
   \   000026   74FF         MOV     A,#-0x1
   \   000028   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000029   7004         JNZ     ??ZDSecMgrAPSRemove_3
   3680            {
   3681              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   00002B   7901         MOV     R1,#0x1
   \   00002D   802E         SJMP    ??ZDSecMgrAPSRemove_4
   3682            }
   3683          
   3684            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   EA           MOV     A,R2
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EB           MOV     A,R3
   \   000039   F0           MOVX    @DPTR,A
   3685            device.extAddr = extAddr;
   \   00003A   7402         MOV     A,#0x2
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   EC           MOV     A,R4
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   ED           MOV     A,R5
   \   000043   F0           MOVX    @DPTR,A
   3686            device.parentAddr = parentAddr;
   \   000044   7404         MOV     A,#0x4
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E8           MOV     A,R0
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   E9           MOV     A,R1
   \   00004D   F0           MOVX    @DPTR,A
   3687          
   3688            // remove device
   3689            ZDSecMgrDeviceRemove( &device );
   \   00004E                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   AA82         MOV     R2,DPL
   \   000056   AB83         MOV     R3,DPH
   \   000058   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   3690          
   3691            return ( ZSuccess );
   \   00005B   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   00005D   740A         MOV     A,#0xa
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   D083         POP     DPH
   \   000064   D082         POP     DPL
   \   000066   02....       LJMP    ?BRET
   3692          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrTCMasterKey>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_b:
   \   000000   0B000000     DD 11

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlRelease?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlTerm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendMasterKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrMgrUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlSetup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_SKA_TimerExpired?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateSKKE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateCM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthInitiate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestAppKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetupPartner?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_MasterKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyDataGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyDataGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInitNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetDefaultNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrWriteNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrWriteNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRestoreFromNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRestoreFromNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove
   3693          
   3694          /******************************************************************************
   3695          ******************************************************************************/
   3696          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     APSME_KeyFwdToChild                0      0      9
       -> AssocGetWithExt               0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     APSME_LinkKeyDataGet               0      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     APSME_LinkKeySet                   0      0     32
       -> ZDSecMgrEntryLookupExt        0      0     26
       -> osal_memcpy                   0      0     32
     APSME_MasterKeyGet                 0      0     11
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrMasterKeyLookup       0      0     22
     APSME_SKA_TimerExpired             0      0      0
     ZDSecMgrAPSRemove                  2      0     12
       -> ZDSecMgrDeviceRemove          4      0     20
     ZDSecMgrAddLinkKey                 0      0     20
       -> ZDSecMgrAddrStore             0      0     36
       -> ZDSecMgrEntryLookupAMI        0      0     32
       -> ZDSecMgrEntryNew              0      0     32
       -> APSME_LinkKeySet              0      0     32
       -> ZDSecMgrWriteNV               0      0     32
     ZDSecMgrAddrMgrUpdate              0      0     36
       -> AddrMgrEntryGet               0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAddrStore                  0      0     40
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAppKeyGet                  1      0     68
       -> SSP_GetTrueRand               0      0     18
     ZDSecMgrAppKeyReq                  0      0     59
       -> APSME_LookupNwkAddr           0      0    102
       -> APSME_LookupExtAddr           0      0    102
       -> ZDSecMgrAppKeyGet             0      0    118
       -> APSME_TransportKeyReq         0      0    102
       -> APSME_TransportKeyReq         0      0    102
     ZDSecMgrAssocDeviceAuth            2      0     35
     ZDSecMgrAuthInitiate               0      0     16
       -> APSME_LookupNwkAddr           0      0     32
       -> APSME_AuthenticateReq         0      0     32
     ZDSecMgrAuthNwkKey                 2      0     10
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateCfm            2      0      0
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateInd            0      0     32
       -> AddrMgrExtAddrSet             0      0     64
       -> AddrMgrEntryUpdate            0      0     64
       -> APSME_AuthenticateReq         0      0     64
     ZDSecMgrAuthenticationCheck        0      0      0
     ZDSecMgrAuthenticationSet          1      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     ZDSecMgrConfig                     2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrCtrlAdd                    0      0     26
       -> ZDSecMgrCtrlSet               0      0     28
     ZDSecMgrCtrlInit                   2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrCtrlLookup                 0      0     23
     ZDSecMgrCtrlRelease                2      0      9
     ZDSecMgrCtrlReset                  0      0     14
       -> ZDSecMgrCtrlLookup            0      0     24
       -> ZDSecMgrCtrlSet               0      0     28
       -> ZDSecMgrCtrlAdd               0      0     24
     ZDSecMgrCtrlSet                    1      0     23
     ZDSecMgrCtrlTerm                   2      0      2
       -> ZDSecMgrCtrlLookup            4      0      4
       -> ZDSecMgrCtrlRelease           4      0      4
     ZDSecMgrDeviceCtrlHandler          1      0     42
       -> ZDSecMgrSendMasterKey         0      0     18
       -> ZDSecMgrEstablishKey          0      0     18
       -> ZDSecMgrSendNwkKey            0      0     18
       -> osal_start_timerEx            0      0     18
       -> ZDSecMgrCtrlRelease           0      0     18
     ZDSecMgrDeviceCtrlSetup            2      0      0
       -> ZDSecMgrDeviceCtrlHandler     4      0      0
     ZDSecMgrDeviceCtrlUpdate           0      0     13
       -> ZDSecMgrEntryLookupExt        0      0     26
       -> ZDSecMgrCtrlLookup            0      0     26
     ZDSecMgrDeviceEntryAdd             0      0     28
       -> ZDSecMgrEntryLookup           0      0     28
       -> ZDSecMgrDeviceEntryRemove     0      0     28
       -> ZDSecMgrEntryLookupAMI        0      0     28
       -> ZDSecMgrAddrMgrUpdate         0      0     28
       -> ZDSecMgrEntryLookupAMI        0      0     28
       -> ZDSecMgrEntryNew              0      0     28
       -> ZDSecMgrAddrMgrUpdate         0      0     28
     ZDSecMgrDeviceEntryRemove          2      0     14
       -> ZDSecMgrEntryFree             4      0      0
     ZDSecMgrDeviceJoin                 0      0     19
       -> ZDSecMgrDeviceValidate        0      0     18
       -> ZDSecMgrSendNwkKey            0      0     18
       -> ZDSecMgrDeviceRemove          0      0     18
     ZDSecMgrDeviceJoinDirect           0      0      9
       -> ZDSecMgrDeviceJoin            0      0     18
       -> AssocGetWithShort             0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     ZDSecMgrDeviceJoinFwd              2      0      8
       -> APSME_UpdateDeviceReq         4      0     16
     ZDSecMgrDeviceNew                  2      0     35
       -> ZDSecMgrDeviceJoinFwd         4      0      0
     ZDSecMgrDeviceRemove               2      0     40
       -> NLME_GetShortAddr             4      0     42
       -> AssocGetWithExt               0      0     42
       -> NLME_LeaveReq                 0      0     42
       -> APSME_RemoveDeviceReq         0      0     42
     ZDSecMgrDeviceValidate             2      0      9
       -> ZDSecMgrDeviceValidateRM      4      0      0
     ZDSecMgrDeviceValidateCM           0      0     16
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLoad         0      0     28
       -> ZDSecMgrDeviceEntryAdd        0      0     28
     ZDSecMgrDeviceValidateRM           2      0      0
     ZDSecMgrDeviceValidateSKKE         0      0     42
       -> ZDSecMgrExtAddrLookup         0      0     26
       -> ZDSecMgrMasterKeyLookup       0      0     26
       -> ZDSecMgrDeviceEntryAdd        0      0     26
     ZDSecMgrEntryFree                  2      0      0
     ZDSecMgrEntryInit                  2      0      0
       -> osal_mem_alloc                4      0      0
       -> ZDSecMgrRestoreFromNV         4      0      0
     ZDSecMgrEntryLookup                0      0     37
       -> AddrMgrEntryLookupNwk         0      0     46
     ZDSecMgrEntryLookupAMI             0      0     26
     ZDSecMgrEntryLookupExt             0      0     24
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrEntryLookupAMI        0      0     22
     ZDSecMgrEntryNew                   0      0     26
     ZDSecMgrEstablishKey               2      0     28
       -> NLME_GetShortAddr             4      0     38
       -> APSME_EstablishKeyReq         0      0     38
     ZDSecMgrEstablishKeyCfm            0      0      0
     ZDSecMgrEstablishKeyInd            1      0     29
       -> ZDSecMgrTCDataLoad            0      0     58
       -> ZDSecMgrTCExtAddrCheck        0      0     58
       -> ZDSecMgrDeviceValidateSKKE
                                        0      0     58
       -> APSME_EstablishKeyRsp         0      0     58
     ZDSecMgrEvent                      1      0     33
       -> AddrMgrEntryGet               0      0     66
       -> ZDSecMgrDeviceCtrlHandler     0      0     66
       -> osal_start_timerEx            0      0     66
     ZDSecMgrExtAddrLookup              0      0     41
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryLookupExt         0      0     44
     ZDSecMgrExtAddrStore               0      0     24
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrInit                       2      0      0
       -> ZDSecMgrConfig                4      0      0
     ZDSecMgrInitNV                     0      0     12
       -> osal_nv_item_init             0      0     24
       -> ZDSecMgrSetDefaultNV          0      0     20
     ZDSecMgrMasterKeyInit              2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrMasterKeyLoad              0      0     36
       -> ZDSecMgrExtAddrLookup         0      0     38
       -> ZDSecMgrMasterKeyLookup       0      0     38
       -> osal_memcpy                   0      0     44
       -> ZDSecMgrMasterKeyStore        0      0     38
     ZDSecMgrMasterKeyLookup            0      0     35
     ZDSecMgrMasterKeyStore             0      0     36
       -> osal_memset                   0      0     28
       -> osal_memcpy                   0      0     34
     ZDSecMgrNewDeviceEvent             1      0     35
       -> AssocMatchDeviceStatus        0      0     70
       -> ZDSecMgrAssocDeviceAuth       0      0     70
       -> AddrMgrEntryGet               0      0     70
       -> NLME_GetShortAddr             0      0     70
       -> ZDSecMgrDeviceNew             0      0     70
       -> AssocRemove                   0      0     70
     ZDSecMgrPermitJoining              2      0      0
     ZDSecMgrPermitJoiningTimeout       2      0      0
     ZDSecMgrRemoveDeviceInd            0      0     19
       -> APSME_LookupNwkAddr           0      0     38
       -> NLME_GetShortAddr             0      0     38
       -> ZDSecMgrDeviceRemove          0      0     38
     ZDSecMgrRequestAppKey              2      0     12
       -> AddrMgrExtAddrLookup          4      0     24
       -> APSME_RequestKeyReq           4      0     24
     ZDSecMgrRequestKeyInd              2      0      0
       -> ZDSecMgrAppKeyReq             4      0      0
     ZDSecMgrRestoreFromNV              0      0     19
       -> osal_nv_read                  0      0     38
       -> osal_nv_read                  0      0     38
       -> ZDSecMgrWriteNV               0      0     30
     ZDSecMgrSendMasterKey              2      0     34
       -> ZDSecMgrMasterKeyLookup       0      0     50
       -> NLME_GetShortAddr             4      0     50
       -> APSME_TransportKeyReq         0      0     50
     ZDSecMgrSendNwkKey                 2      0     34
       -> NLME_GetShortAddr             4      0     50
       -> NLME_GetShortAddr             4      0     50
       -> APSME_TransportKeyReq         0      0     50
     ZDSecMgrSetDefaultNV               0      0     26
       -> osal_nv_write                 0      0     32
     ZDSecMgrSetupPartner               0      0     24
       -> AddrMgrExtAddrSet             0      0     48
       -> AddrMgrEntryUpdate            0      0     48
       -> ZDP_NwkAddrReq                0      0     48
       -> AddrMgrExtAddrValid           0      0     48
       -> ZDP_IEEEAddrReq               0      0     48
     ZDSecMgrSwitchKeyInd               2      0      0
       -> SSP_SwitchNwkKey              4      0      0
       -> ZDApp_NVUpdate                4      0      0
     ZDSecMgrTCDataLoad                 0      0     45
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     28
       -> ZDSecMgrMasterKeyStore        0      0     28
     ZDSecMgrTCExtAddrCheck             0      0     46
       -> AddrMgrExtAddrLookup          0      0     34
       -> AddrMgrExtAddrEqual           0      0     34
     ZDSecMgrTransportKeyInd            0      0     10
       -> ZDSecMgrTCDataLoad            0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> ZDSecMgrAuthNwkKey            0      0     20
     ZDSecMgrUpdateDeviceInd            2      0     10
       -> ZDSecMgrDeviceJoin            4      0     20
     ZDSecMgrWriteNV                    0      0     32
       -> osal_nv_write                 0      0     32
       -> osal_nv_write                 0      0     32


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     ZDSecMgrTCExtAddr                         8
     ZDSecMgrTCMasterKey                      16
     ZDSecMgrTCAuthenticated                   1
     ZDSecMgrTCDataLoaded                      1
     ZDSecMgrMasterKeyData                     2
     ZDSecMgrEntries                           2
     ZDSecMgrCtrlData                          2
     ZDSecMgrPermitJoiningEnabled              1
     ZDSecMgrPermitJoiningTimed                1
     TrustCenterLinkKey                       10
     ZDSecMgrMasterKeyInit                    99
     ZDSecMgrAddrStore                       122
     ZDSecMgrExtAddrStore                    122
     ZDSecMgrExtAddrLookup                   111
     ZDSecMgrMasterKeyLookup                 130
     ZDSecMgrMasterKeyStore                  180
     ZDSecMgrEntryInit                       102
     ZDSecMgrEntryLookup                     183
     ZDSecMgrEntryLookupAMI                  126
     ZDSecMgrEntryLookupExt                   74
     ZDSecMgrEntryFree                        21
     ZDSecMgrEntryNew                        146
     ZDSecMgrCtrlInit                        100
     ZDSecMgrCtrlRelease                      22
     ZDSecMgrCtrlLookup                      138
     ZDSecMgrCtrlSet                         114
     ZDSecMgrCtrlAdd                         129
     ZDSecMgrCtrlTerm                         63
     ZDSecMgrCtrlReset                       100
     ZDSecMgrMasterKeyLoad                   127
     ZDSecMgrAppKeyType                        1
     ZDSecMgrAppKeyGet                        55
     ZDSecMgrAppKeyReq                       326
     ZDSecMgrEstablishKey                    179
     ZDSecMgrSendMasterKey                   233
     ZDSecMgrSendNwkKey                      264
     ZDSecMgrDeviceEntryRemove                14
     ZDSecMgrAddrMgrUpdate                    93
     ZDSecMgrDeviceEntryAdd                  236
     ZDSecMgrDeviceCtrlHandler               155
     ZDSecMgrDeviceCtrlSetup                  85
     ZDSecMgrDeviceCtrlUpdate                150
     APSME_SKA_TimerExpired                    3
     ZDSecMgrDeviceRemove                    237
     ZDSecMgrDeviceValidateSKKE               95
     ZDSecMgrDeviceValidateRM                 21
     ZDSecMgrDeviceValidateCM                127
     ZDSecMgrDeviceValidate                   52
     ZDSecMgrDeviceJoin                       43
     ZDSecMgrDeviceJoinDirect                 39
     ZDSecMgrDeviceJoinFwd                   197
     ZDSecMgrDeviceNew                        14
     ZDSecMgrAssocDeviceAuth                  28
     ZDSecMgrAuthInitiate                     79
     ZDSecMgrAuthNwkKey                       31
     ZDSecMgrInit                             14
     ZDSecMgrConfig                           14
     ZDSecMgrPermitJoining                    43
     ZDSecMgrPermitJoiningTimeout             28
     ZDSecMgrNewDeviceEvent                  225
     ZDSecMgrEvent                           332
     ZDSecMgrEstablishKeyCfm                   3
     ZDSecMgrTCExtAddrCheck                   69
     ZDSecMgrTCDataLoad                      120
     ZDSecMgrEstablishKeyInd                 283
     ZDSecMgrTransportKeyInd                 157
     ZDSecMgrUpdateDeviceInd                  99
     ZDSecMgrRemoveDeviceInd                 101
     ZDSecMgrRequestKeyInd                    34
     ZDSecMgrSwitchKeyInd                     27
     ZDSecMgrAuthenticateInd                 177
     ZDSecMgrAuthenticateCfm                  55
     ZDSecMgrRequestAppKey                    87
     ZDSecMgrSetupPartner                    135
     APSME_MasterKeyGet                       72
     APSME_LinkKeySet                        133
     ZDSecMgrAuthenticationSet                63
     ZDSecMgrAuthenticationCheck               5
     APSME_LinkKeyDataGet                    105
     APSME_KeyFwdToChild                      74
     ZDSecMgrAddLinkKey                      157
     ZDSecMgrInitNV                           45
     ZDSecMgrSetDefaultNV                     74
     ZDSecMgrWriteNV                         220
     ZDSecMgrRestoreFromNV                   202
     ZDSecMgrAPSRemove                       105
     ?<Initializer for ZDSecMgrTCMasterKey>   16
     ?<Initializer for ZDSecMgrAppKeyType>     1
     __Constant_0                              4
     __Constant_b                              4
     ??ZDSecMgrMasterKeyInit?relay             6
     ??ZDSecMgrAddrStore?relay                 6
     ??ZDSecMgrExtAddrStore?relay              6
     ??ZDSecMgrExtAddrLookup?relay             6
     ??ZDSecMgrMasterKeyLookup?relay           6
     ??ZDSecMgrMasterKeyStore?relay            6
     ??ZDSecMgrEntryInit?relay                 6
     ??ZDSecMgrEntryLookup?relay               6
     ??ZDSecMgrEntryLookupAMI?relay            6
     ??ZDSecMgrEntryLookupExt?relay            6
     ??ZDSecMgrEntryFree?relay                 6
     ??ZDSecMgrEntryNew?relay                  6
     ??ZDSecMgrCtrlInit?relay                  6
     ??ZDSecMgrCtrlRelease?relay               6
     ??ZDSecMgrCtrlLookup?relay                6
     ??ZDSecMgrCtrlSet?relay                   6
     ??ZDSecMgrCtrlAdd?relay                   6
     ??ZDSecMgrCtrlTerm?relay                  6
     ??ZDSecMgrCtrlReset?relay                 6
     ??ZDSecMgrMasterKeyLoad?relay             6
     ??ZDSecMgrAppKeyGet?relay                 6
     ??ZDSecMgrAppKeyReq?relay                 6
     ??ZDSecMgrEstablishKey?relay              6
     ??ZDSecMgrSendMasterKey?relay             6
     ??ZDSecMgrSendNwkKey?relay                6
     ??ZDSecMgrDeviceEntryRemove?relay         6
     ??ZDSecMgrAddrMgrUpdate?relay             6
     ??ZDSecMgrDeviceEntryAdd?relay            6
     ??ZDSecMgrDeviceCtrlHandler?relay         6
     ??ZDSecMgrDeviceCtrlSetup?relay           6
     ??ZDSecMgrDeviceCtrlUpdate?relay          6
     ??APSME_SKA_TimerExpired?relay            6
     ??ZDSecMgrDeviceRemove?relay              6
     ??ZDSecMgrDeviceValidateSKKE?relay        6
     ??ZDSecMgrDeviceValidateRM?relay          6
     ??ZDSecMgrDeviceValidateCM?relay          6
     ??ZDSecMgrDeviceValidate?relay            6
     ??ZDSecMgrDeviceJoin?relay                6
     ??ZDSecMgrDeviceJoinDirect?relay          6
     ??ZDSecMgrDeviceJoinFwd?relay             6
     ??ZDSecMgrDeviceNew?relay                 6
     ??ZDSecMgrAssocDeviceAuth?relay           6
     ??ZDSecMgrAuthInitiate?relay              6
     ??ZDSecMgrAuthNwkKey?relay                6
     ??ZDSecMgrInit?relay                      6
     ??ZDSecMgrConfig?relay                    6
     ??ZDSecMgrPermitJoining?relay             6
     ??ZDSecMgrPermitJoiningTimeout?relay      6
     ??ZDSecMgrNewDeviceEvent?relay            6
     ??ZDSecMgrEvent?relay                     6
     ??ZDSecMgrEstablishKeyCfm?relay           6
     ??ZDSecMgrTCExtAddrCheck?relay            6
     ??ZDSecMgrTCDataLoad?relay                6
     ??ZDSecMgrEstablishKeyInd?relay           6
     ??ZDSecMgrTransportKeyInd?relay           6
     ??ZDSecMgrUpdateDeviceInd?relay           6
     ??ZDSecMgrRemoveDeviceInd?relay           6
     ??ZDSecMgrRequestKeyInd?relay             6
     ??ZDSecMgrSwitchKeyInd?relay              6
     ??ZDSecMgrAuthenticateInd?relay           6
     ??ZDSecMgrAuthenticateCfm?relay           6
     ??ZDSecMgrRequestAppKey?relay             6
     ??ZDSecMgrSetupPartner?relay              6
     ??APSME_MasterKeyGet?relay                6
     ??APSME_LinkKeySet?relay                  6
     ??ZDSecMgrAuthenticationSet?relay         6
     ??ZDSecMgrAuthenticationCheck?relay       6
     ??APSME_LinkKeyDataGet?relay              6
     ??APSME_KeyFwdToChild?relay               6
     ??ZDSecMgrAddLinkKey?relay                6
     ??ZDSecMgrInitNV?relay                    6
     ??ZDSecMgrSetDefaultNV?relay              6
     ??ZDSecMgrWriteNV?relay                   6
     ??ZDSecMgrRestoreFromNV?relay             6
     ??ZDSecMgrAPSRemove?relay                 6

 
 8 223 bytes in segment BANKED_CODE
   450 bytes in segment BANK_RELAYS
    17 bytes in segment XDATA_I
    17 bytes in segment XDATA_ID
     8 bytes in segment XDATA_ROM_C
    28 bytes in segment XDATA_Z
 
 8 690 bytes of CODE  memory
     0 bytes of CONST memory (+ 8 bytes shared)
    45 bytes of XDATA memory

Errors: none
Warnings: none
